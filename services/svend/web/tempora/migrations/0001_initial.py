# Generated by Django 5.2.10 on 2026-01-27 23:48

import django.db.models.deletion
import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='CircuitBreakerState',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('service_name', models.CharField(db_index=True, help_text="Service identifier (e.g., 'external_api', 'database')", max_length=255, unique=True)),
                ('state', models.CharField(choices=[('closed', 'closed'), ('open', 'open'), ('half_open', 'half_open')], default='closed', help_text='Current circuit state', max_length=20)),
                ('failure_count', models.PositiveIntegerField(default=0, help_text='Consecutive failure count')),
                ('success_count', models.PositiveIntegerField(default=0, help_text='Success count in half-open state')),
                ('half_open_calls', models.PositiveIntegerField(default=0, help_text='Calls made in half-open state')),
                ('failure_threshold', models.PositiveIntegerField(default=5, help_text='Failures before opening circuit')),
                ('recovery_timeout_seconds', models.PositiveIntegerField(default=30, help_text='Seconds before testing recovery')),
                ('success_threshold', models.PositiveIntegerField(default=3, help_text='Successes needed to close circuit')),
                ('half_open_max_calls', models.PositiveIntegerField(default=3, help_text='Max calls in half-open state')),
                ('last_failure_at', models.DateTimeField(blank=True, help_text='Last failure timestamp', null=True)),
                ('opened_at', models.DateTimeField(blank=True, help_text='When circuit was opened', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='Circuit breaker creation timestamp (FLD-001)')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp (FLD-001)')),
            ],
            options={
                'verbose_name': 'Circuit Breaker State',
                'verbose_name_plural': 'Circuit Breaker States',
                'db_table': 'sched_circuit_breaker',
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='ClusterMember',
            fields=[
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, help_text='Unique cluster member identifier', primary_key=True, serialize=False)),
                ('instance_id', models.CharField(db_index=True, help_text="Unique instance identifier (e.g., 'tempora-1')", max_length=255, unique=True)),
                ('host', models.CharField(help_text='Host address for coordination (IP or hostname)', max_length=255)),
                ('port', models.IntegerField(default=9500, help_text='Port for coordination protocol')),
                ('role', models.CharField(choices=[('leader', 'Leader'), ('follower', 'Follower'), ('candidate', 'Candidate'), ('observer', 'Observer')], db_index=True, default='follower', help_text='Current role in the cluster', max_length=20)),
                ('status', models.CharField(choices=[('active', 'Active'), ('suspected', 'Suspected'), ('failed', 'Failed'), ('draining', 'Draining'), ('offline', 'Offline')], db_index=True, default='active', help_text='Current status', max_length=20)),
                ('current_term', models.BigIntegerField(default=0, help_text='Current election term')),
                ('voted_for', models.CharField(blank=True, help_text='Instance ID voted for in current term', max_length=255, null=True)),
                ('last_heartbeat', models.DateTimeField(blank=True, db_index=True, help_text='Last heartbeat received from this member', null=True)),
                ('heartbeat_latency_ms', models.FloatField(blank=True, help_text='Average heartbeat round-trip time in milliseconds', null=True)),
                ('consecutive_missed', models.IntegerField(default=0, help_text='Number of consecutive missed heartbeats')),
                ('joined_at', models.DateTimeField(auto_now_add=True, help_text='When this member joined the cluster')),
                ('metadata', models.JSONField(blank=True, default=dict, help_text='Additional metadata (version, capabilities, etc.)')),
            ],
            options={
                'verbose_name': 'Cluster Member',
                'verbose_name_plural': 'Cluster Members',
                'db_table': 'sched_cluster_member',
                'ordering': ['-role', 'instance_id'],
                'abstract': False,
                'indexes': [models.Index(fields=['status', 'role'], name='sched_clust_status_9e7f23_idx'), models.Index(fields=['last_heartbeat'], name='sched_clust_last_he_ab8e29_idx')],
            },
        ),
        migrations.CreateModel(
            name='DistributedLogEntry',
            fields=[
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, help_text='Unique log entry identifier', primary_key=True, serialize=False)),
                ('tenant_id', models.UUIDField(db_index=True, help_text='Tenant isolation identifier')),
                ('index', models.BigIntegerField(db_index=True, help_text='Sequential position in the log (monotonically increasing)')),
                ('term', models.BigIntegerField(help_text='Election term when entry was created')),
                ('command', models.CharField(choices=[('TASK_CREATED', 'Task Created'), ('TASK_ASSIGNED', 'Task Assigned'), ('TASK_COMPLETED', 'Task Completed'), ('TASK_FAILED', 'Task Failed'), ('SCHEDULE_ACTIVATED', 'Schedule Activated'), ('SCHEDULE_PAUSED', 'Schedule Paused'), ('PRIORITY_CHANGED', 'Priority Changed'), ('CONFIG_CHANGED', 'Config Changed')], help_text='Type of state change command', max_length=50)),
                ('data', models.JSONField(default=dict, help_text='Command payload (task_id, parameters, etc.)')),
                ('committed', models.BooleanField(db_index=True, default=False, help_text='True when replicated to majority and committed')),
                ('created_by', models.CharField(help_text='Instance ID that created this entry (always the leader)', max_length=255)),
                ('commit_timestamp', models.DateTimeField(blank=True, help_text='When entry was committed (replicated to quorum)', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, help_text='When entry was created')),
            ],
            options={
                'verbose_name': 'Distributed Log Entry',
                'verbose_name_plural': 'Distributed Log Entries',
                'db_table': 'sched_distributed_log',
                'ordering': ['index'],
                'abstract': False,
                'indexes': [models.Index(fields=['tenant_id', 'index', 'term'], name='idx_distlog_tenant_index_term'), models.Index(fields=['committed', 'index'], name='idx_distlog_committed_index'), models.Index(fields=['command'], name='idx_distlog_command')],
                'constraints': [models.UniqueConstraint(fields=('tenant_id', 'index', 'term'), name='unique_log_entry'), models.CheckConstraint(condition=models.Q(('index__gt', 0)), name='positive_log_index'), models.CheckConstraint(condition=models.Q(('term__gte', 0)), name='non_negative_log_term')],
            },
        ),
        migrations.CreateModel(
            name='FencingToken',
            fields=[
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp')),
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, help_text='Unique token record identifier', primary_key=True, serialize=False)),
                ('tenant_id', models.UUIDField(db_index=True, help_text='Tenant isolation identifier')),
                ('token', models.BigIntegerField(db_index=True, help_text='Monotonically increasing token value')),
                ('issued_to', models.CharField(help_text='Instance ID that holds this token', max_length=255)),
                ('term', models.BigIntegerField(help_text='Election term when token was issued')),
                ('is_current', models.BooleanField(db_index=True, default=True, help_text='Whether this is the current valid token')),
                ('issued_at', models.DateTimeField(auto_now_add=True, help_text='When token was issued')),
            ],
            options={
                'verbose_name': 'Fencing Token',
                'verbose_name_plural': 'Fencing Tokens',
                'db_table': 'sched_fencing_token',
                'ordering': ['-token'],
                'abstract': False,
                'indexes': [models.Index(fields=['tenant_id', 'is_current'], name='idx_fencing_tenant_current')],
                'constraints': [models.CheckConstraint(condition=models.Q(('token__gt', 0)), name='positive_fencing_token')],
            },
        ),
        migrations.CreateModel(
            name='Schedule',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('tenant_id', models.UUIDField(db_index=True, help_text='Tenant isolation identifier')),
                ('schedule_id', models.CharField(db_index=True, help_text='Human-readable schedule identifier', max_length=100)),
                ('name', models.CharField(help_text='Schedule name/description', max_length=255)),
                ('task_name', models.CharField(help_text='Task handler name to invoke', max_length=255)),
                ('payload_template', models.JSONField(default=dict, help_text='Template for task payload')),
                ('queue', models.CharField(default='core', help_text='Target queue for scheduled tasks', max_length=50)),
                ('priority', models.PositiveSmallIntegerField(default=2, help_text='Priority for scheduled tasks')),
                ('schedule_type', models.CharField(choices=[('cron', 'cron'), ('interval', 'interval'), ('one_time', 'one_time')], help_text='Schedule type (cron/interval/once)', max_length=20)),
                ('cron_minute', models.CharField(default='*', max_length=50)),
                ('cron_hour', models.CharField(default='*', max_length=50)),
                ('cron_day_of_month', models.CharField(default='*', max_length=50)),
                ('cron_month', models.CharField(default='*', max_length=50)),
                ('cron_day_of_week', models.CharField(default='*', max_length=50)),
                ('interval_seconds', models.PositiveIntegerField(default=0, help_text='Interval in seconds')),
                ('run_at', models.DateTimeField(blank=True, help_text='One-time execution timestamp', null=True)),
                ('enabled', models.BooleanField(db_index=True, default=True, help_text='Whether schedule is active')),
                ('last_run_at', models.DateTimeField(blank=True, help_text='Last successful execution time', null=True)),
                ('next_run_at', models.DateTimeField(blank=True, db_index=True, help_text='Next scheduled execution time', null=True)),
                ('run_count', models.PositiveIntegerField(default=0, help_text='Total execution count')),
                ('max_runs', models.PositiveIntegerField(blank=True, help_text='Maximum number of runs (null = unlimited)', null=True)),
                ('expires_at', models.DateTimeField(blank=True, help_text='Schedule expiration time', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('created_by', models.CharField(blank=True, help_text='Creator identifier', max_length=255, null=True)),
            ],
            options={
                'verbose_name': 'Schedule',
                'verbose_name_plural': 'Schedules',
                'db_table': 'sched_schedule',
                'ordering': ['next_run_at'],
                'abstract': False,
                'indexes': [models.Index(fields=['tenant_id', 'enabled', 'next_run_at'], name='idx_schedule_tenant_enabled')],
                'unique_together': {('tenant_id', 'schedule_id')},
            },
        ),
        migrations.CreateModel(
            name='CognitiveTask',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, help_text='Unique task identifier', primary_key=True, serialize=False)),
                ('tenant_id', models.UUIDField(db_index=True, help_text='Tenant isolation identifier')),
                ('task_name', models.CharField(db_index=True, help_text="Task type/handler name (e.g., 'reflex.escalation.handler')", max_length=255)),
                ('correlation_id', models.UUIDField(db_index=True, default=uuid.uuid4, help_text='Correlation ID for distributed tracing')),
                ('root_correlation_id', models.UUIDField(blank=True, db_index=True, help_text='Root correlation for cascade chains', null=True)),
                ('parent_task_id', models.UUIDField(blank=True, db_index=True, help_text='Parent task ID for cascade lineage', null=True)),
                ('cascade_depth', models.PositiveSmallIntegerField(default=0, help_text='Depth in cascade chain (0 = root task)')),
                ('idempotency_key', models.CharField(blank=True, db_index=True, help_text='Unique key for idempotent task creation (prevents duplicates)', max_length=255, null=True)),
                ('idempotency_expires_at', models.DateTimeField(blank=True, db_index=True, help_text='When idempotency key expires (for TTL cleanup)', null=True)),
                ('payload', models.JSONField(default=dict, help_text='Task arguments/payload as JSON')),
                ('queue', models.CharField(db_index=True, default='core', help_text='Target queue for routing', max_length=50)),
                ('priority', models.PositiveSmallIntegerField(db_index=True, default=2, help_text='Task priority (0=critical, 4=batch)')),
                ('reflex_source', models.CharField(blank=True, help_text='Originating reflex ID if task was triggered by reflex', max_length=255, null=True)),
                ('confidence_score', models.FloatField(default=1.0, help_text='Confidence in task necessity (0.0-1.0)')),
                ('urgency', models.FloatField(default=0.5, help_text='Task urgency level (0.0-1.0)')),
                ('governance_risk', models.FloatField(default=0.0, help_text='Governance risk score (0.0-1.0, higher=riskier)')),
                ('resource_weight', models.FloatField(default=1.0, help_text='Relative resource consumption weight')),
                ('priority_score', models.FloatField(db_index=True, default=0.5, help_text='Computed priority score for scheduling')),
                ('state', models.CharField(choices=[('pending', 'pending'), ('scheduled', 'scheduled'), ('running', 'running'), ('success', 'success'), ('failure', 'failure'), ('retrying', 'retrying'), ('dead_lettered', 'dead_lettered'), ('cancelled', 'cancelled')], db_index=True, default='pending', help_text='Current task state', max_length=20)),
                ('attempts', models.PositiveSmallIntegerField(default=0, help_text='Number of execution attempts')),
                ('max_attempts', models.PositiveSmallIntegerField(default=3, help_text='Maximum execution attempts before DLQ')),
                ('retry_strategy', models.CharField(choices=[('immediate', 'immediate'), ('linear', 'linear'), ('exponential', 'exponential'), ('fibonacci', 'fibonacci')], default='exponential', help_text='Retry backoff strategy', max_length=30)),
                ('retry_base_delay', models.PositiveIntegerField(default=1, help_text='Base delay for retry in seconds')),
                ('retry_max_delay', models.PositiveIntegerField(default=3600, help_text='Maximum retry delay in seconds')),
                ('next_retry_at', models.DateTimeField(blank=True, db_index=True, help_text='Scheduled time for next retry attempt', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_index=True, help_text='Task creation timestamp')),
                ('scheduled_at', models.DateTimeField(blank=True, db_index=True, help_text='When task was scheduled for execution', null=True)),
                ('started_at', models.DateTimeField(blank=True, help_text='Execution start time', null=True)),
                ('completed_at', models.DateTimeField(blank=True, help_text='Execution completion time', null=True)),
                ('deadline', models.DateTimeField(blank=True, db_index=True, help_text='Hard deadline for task completion', null=True)),
                ('timeout_seconds', models.PositiveIntegerField(default=60, help_text='Execution timeout in seconds')),
                ('result', models.JSONField(blank=True, help_text='Task execution result', null=True)),
                ('error_message', models.TextField(blank=True, help_text='Error message if failed', null=True)),
                ('error_type', models.CharField(blank=True, help_text='Error type classification', max_length=255, null=True)),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp (FLD-001)')),
                ('schedule', models.ForeignKey(blank=True, help_text='Associated schedule for recurring tasks', null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='tasks', to='tempora.schedule')),
            ],
            options={
                'verbose_name': 'Cognitive Task',
                'verbose_name_plural': 'Cognitive Tasks',
                'db_table': 'sched_cognitive_task',
                'ordering': ['-priority_score', 'created_at'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='TaskExecution',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('attempt_number', models.PositiveSmallIntegerField(help_text='Attempt number (1-indexed)')),
                ('worker_id', models.CharField(blank=True, help_text='Worker instance that executed this attempt', max_length=255, null=True)),
                ('started_at', models.DateTimeField(auto_now_add=True, help_text='Execution start time')),
                ('completed_at', models.DateTimeField(blank=True, help_text='Execution completion time', null=True)),
                ('duration_ms', models.PositiveIntegerField(blank=True, help_text='Execution duration in milliseconds', null=True)),
                ('success', models.BooleanField(default=False, help_text='Whether execution succeeded')),
                ('result', models.JSONField(blank=True, help_text='Execution result', null=True)),
                ('error_message', models.TextField(blank=True, help_text='Error message if failed', null=True)),
                ('error_type', models.CharField(blank=True, help_text='Error classification (transient/permanent/rate_limited)', max_length=255, null=True)),
                ('error_traceback', models.TextField(blank=True, help_text='Full error traceback', null=True)),
                ('memory_peak_mb', models.FloatField(blank=True, help_text='Peak memory usage in MB', null=True)),
                ('cpu_time_ms', models.PositiveIntegerField(blank=True, help_text='CPU time in milliseconds', null=True)),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp (FLD-001)')),
                ('task', models.ForeignKey(help_text='Parent task', on_delete=django.db.models.deletion.CASCADE, related_name='executions', to='tempora.cognitivetask')),
            ],
            options={
                'verbose_name': 'Task Execution',
                'verbose_name_plural': 'Task Executions',
                'db_table': 'sched_task_execution',
                'ordering': ['-started_at'],
                'abstract': False,
            },
        ),
        migrations.CreateModel(
            name='DeadLetterEntry',
            fields=[
                ('id', models.UUIDField(default=uuid.uuid4, editable=False, primary_key=True, serialize=False)),
                ('tenant_id', models.UUIDField(db_index=True, help_text='Tenant isolation identifier')),
                ('failure_reason', models.TextField(help_text='Reason for DLQ placement')),
                ('failure_count', models.PositiveIntegerField(help_text='Total failure count before DLQ')),
                ('last_error_message', models.TextField(blank=True, help_text='Last error message', null=True)),
                ('last_error_type', models.CharField(blank=True, help_text='Last error classification', max_length=255, null=True)),
                ('last_error_traceback', models.TextField(blank=True, help_text='Last error traceback', null=True)),
                ('status', models.CharField(choices=[('pending', 'Pending Review'), ('reviewing', 'Under Review'), ('reprocessing', 'Reprocessing'), ('resolved', 'Resolved'), ('discarded', 'Discarded')], db_index=True, default='pending', help_text='DLQ entry status', max_length=20)),
                ('resolution_notes', models.TextField(blank=True, help_text='Notes on resolution', null=True)),
                ('resolved_by', models.CharField(blank=True, help_text='Who resolved this entry', max_length=255, null=True)),
                ('resolved_at', models.DateTimeField(blank=True, help_text='Resolution timestamp', null=True)),
                ('reprocess_count', models.PositiveIntegerField(default=0, help_text='Number of reprocess attempts')),
                ('reprocessed_task_id', models.UUIDField(blank=True, help_text='ID of reprocessed task if any', null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True, db_index=True, help_text='Entry creation timestamp (FLD-001)')),
                ('updated_at', models.DateTimeField(auto_now=True, help_text='Last modification timestamp (FLD-001)')),
                ('original_task', models.OneToOneField(help_text='Original failed task', on_delete=django.db.models.deletion.CASCADE, related_name='dlq_entry', to='tempora.cognitivetask')),
            ],
            options={
                'verbose_name': 'Dead Letter Entry',
                'verbose_name_plural': 'Dead Letter Entries',
                'db_table': 'sched_dead_letter',
                'ordering': ['-created_at'],
                'abstract': False,
                'indexes': [models.Index(fields=['tenant_id', 'status'], name='idx_dlq_tenant_status')],
            },
        ),
        migrations.AddIndex(
            model_name='cognitivetask',
            index=models.Index(fields=['tenant_id', 'state', 'priority_score'], name='idx_task_tenant_state_prio'),
        ),
        migrations.AddIndex(
            model_name='cognitivetask',
            index=models.Index(fields=['tenant_id', 'queue', 'state'], name='idx_task_tenant_queue_state'),
        ),
        migrations.AddIndex(
            model_name='cognitivetask',
            index=models.Index(fields=['state', 'next_retry_at'], name='idx_task_retry_pending'),
        ),
        migrations.AddIndex(
            model_name='cognitivetask',
            index=models.Index(fields=['correlation_id'], name='idx_task_correlation'),
        ),
        migrations.AddIndex(
            model_name='cognitivetask',
            index=models.Index(fields=['root_correlation_id'], name='idx_task_root_correlation'),
        ),
        migrations.AddIndex(
            model_name='taskexecution',
            index=models.Index(fields=['task', 'attempt_number'], name='idx_execution_task_attempt'),
        ),
        migrations.AlterUniqueTogether(
            name='taskexecution',
            unique_together={('task', 'attempt_number')},
        ),
    ]
