{% extends "base_app.html" %}
{% block title %}Whiteboard - SVEND{% endblock %}

{% block extra_head %}
<style>
/* ============================================================================
   WHITEBOARD - Visio-like Visual Mapping Tool
   ============================================================================ */

body > main { padding: 0 !important; }
body > main > .container { max-width: none !important; padding: 0 !important; }

.wb-container {
    --wb-bg: #1a1a1a;
    --wb-grid: #252525;
    --wb-accent: #4a9f6e;
    --wb-text: #e8efe8;
    --wb-text-dim: #9aaa9a;
    --wb-border: rgba(74, 159, 110, 0.3);
    --wb-panel: #121a12;

    display: flex;
    flex-direction: column;
    height: calc(100vh - 60px);
    background: var(--wb-bg);
    color: var(--wb-text);
    font-family: 'Inter', -apple-system, sans-serif;
    overflow: hidden;
}

/* Toolbar */
.wb-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--wb-panel);
    border-bottom: 1px solid var(--wb-border);
    flex-shrink: 0;
}

.wb-toolbar-group {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 0 8px;
    border-right: 1px solid var(--wb-border);
}

.wb-toolbar-group:last-child { border-right: none; }

.wb-tool-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 6px;
    color: var(--wb-text-dim);
    cursor: pointer;
    transition: all 0.15s;
}

.wb-tool-btn:hover {
    background: rgba(74, 159, 110, 0.15);
    border-color: var(--wb-border);
    color: var(--wb-text);
}

.wb-tool-btn.active {
    background: rgba(74, 159, 110, 0.25);
    border-color: var(--wb-accent);
    color: var(--wb-accent);
}

.wb-tool-btn svg { width: 20px; height: 20px; }

.wb-color-btn {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.15s;
}

.wb-color-btn:hover { transform: scale(1.1); }
.wb-color-btn.active { border-color: white; }

.wb-toolbar-label {
    font-size: 10px;
    color: var(--wb-text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-right: 8px;
}

.wb-project-group {
    display: flex;
    align-items: center;
    gap: 4px;
}

.wb-project-select {
    background: var(--wb-panel);
    border: 1px solid var(--wb-border);
    padding: 4px 8px;
    font-size: 11px;
    color: var(--wb-text);
    border-radius: 4px;
    max-width: 150px;
    cursor: pointer;
}

.wb-project-select:focus {
    border-color: var(--wb-accent);
    outline: none;
}

.wb-project-link {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    color: var(--wb-text-dim);
    border-radius: 4px;
    transition: all 0.15s;
}

.wb-project-link:hover {
    color: var(--wb-accent);
    background: rgba(74, 159, 110, 0.15);
}

.wb-zoom-display {
    font-size: 11px;
    color: var(--wb-text-dim);
    min-width: 50px;
    text-align: center;
}

/* Main Area */
.wb-main {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* Sidebar */
.wb-sidebar {
    width: 220px;
    background: var(--wb-panel);
    border-right: 1px solid var(--wb-border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.wb-sidebar-section {
    border-bottom: 1px solid var(--wb-border);
}

.wb-sidebar-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    background: rgba(74, 159, 110, 0.1);
    font-size: 11px;
    font-weight: 600;
    color: var(--wb-accent);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    cursor: pointer;
}

.wb-sidebar-content {
    padding: 8px;
}

.wb-shape-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
}

.wb-shape-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    padding: 8px 4px;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--wb-border);
    border-radius: 6px;
    cursor: grab;
    transition: all 0.15s;
}

.wb-shape-item:hover {
    background: rgba(74, 159, 110, 0.15);
    border-color: var(--wb-accent);
}

.wb-shape-item svg {
    width: 28px;
    height: 28px;
    color: var(--wb-text-dim);
}

.wb-shape-item span {
    font-size: 9px;
    color: var(--wb-text-dim);
    text-align: center;
}

.wb-template-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    background: rgba(255,255,255,0.03);
    border: 1px solid var(--wb-border);
    border-radius: 6px;
    margin-bottom: 6px;
    cursor: pointer;
    transition: all 0.15s;
}

.wb-template-item:hover {
    background: rgba(74, 159, 110, 0.15);
    border-color: var(--wb-accent);
}

.wb-template-item .icon {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(74, 159, 110, 0.2);
    border-radius: 6px;
    color: var(--wb-accent);
}

.wb-template-item .info {
    flex: 1;
}

.wb-template-item .name {
    font-size: 12px;
    font-weight: 500;
    color: var(--wb-text);
}

.wb-template-item .desc {
    font-size: 10px;
    color: var(--wb-text-dim);
}

/* Canvas Area */
.wb-canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background:
        linear-gradient(var(--wb-grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--wb-grid) 1px, transparent 1px);
    background-size: 20px 20px;
    background-position: -1px -1px;
}

.wb-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transform-origin: 0 0;
}

/* SVG for connections - inside canvas, transforms with it */
.wb-connections {
    position: absolute;
    top: 0;
    left: 0;
    width: 5000px;
    height: 5000px;
    pointer-events: none;
    overflow: visible;
    z-index: 10;
}

.wb-connections path {
    pointer-events: stroke;
    cursor: pointer;
}

.wb-connections path:hover {
    stroke-width: 3;
}

/* Elements should be above connections */
.wb-element {
    z-index: 2;
}

/* Elements */
.wb-element {
    position: absolute;
    cursor: move;
    user-select: none;
}

.wb-element.selected {
    outline: 2px solid var(--wb-accent);
    outline-offset: 2px;
}

/* Post-it Note */
.wb-postit {
    width: 150px;
    min-height: 100px;
    padding: 12px;
    border-radius: 2px;
    box-shadow: 3px 3px 10px rgba(0,0,0,0.3);
    font-size: 13px;
    line-height: 1.4;
    overflow: hidden;
    background: #feff9c; /* Default yellow */
    color: #333;
}

.wb-postit[contenteditable="true"] {
    cursor: text;
    outline: none;
}

.wb-element.wb-postit.yellow { background-color: #feff9c !important; color: #333 !important; }
.wb-element.wb-postit.green { background-color: #7afcff !important; color: #333 !important; }
.wb-element.wb-postit.pink { background-color: #ff7eb9 !important; color: #333 !important; }
.wb-element.wb-postit.orange { background-color: #ff9f43 !important; color: #333 !important; }
.wb-element.wb-postit.blue { background-color: #74b9ff !important; color: #333 !important; }
.wb-element.wb-postit.purple { background-color: #a29bfe !important; color: #333 !important; }

/* Group/Affinity Header */
.wb-group {
    min-width: 200px;
    min-height: 150px;
    background: rgba(74, 159, 110, 0.1);
    border: 2px dashed var(--wb-accent);
    border-radius: 8px;
    padding: 8px;
}

.wb-group-header {
    padding: 8px 12px;
    background: var(--wb-accent);
    color: white;
    font-weight: 600;
    font-size: 14px;
    border-radius: 4px;
    margin-bottom: 8px;
    cursor: text;
}

/* Process Shapes */
.wb-process-shape {
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--wb-panel);
    border: 2px solid var(--wb-accent);
    color: var(--wb-text);
    font-size: 12px;
    text-align: center;
    padding: 12px;
}

.wb-process-shape.rectangle {
    width: 120px;
    height: 60px;
    border-radius: 4px;
}

.wb-process-shape.diamond {
    width: 80px;
    height: 80px;
    transform: rotate(45deg);
    border-radius: 4px;
}

.wb-process-shape.diamond span {
    transform: rotate(-45deg);
}

.wb-process-shape.oval {
    width: 120px;
    height: 50px;
    border-radius: 25px;
}

.wb-process-shape.parallelogram {
    width: 120px;
    height: 50px;
    transform: skewX(-10deg);
    border-radius: 4px;
}

.wb-process-shape.parallelogram span {
    transform: skewX(10deg);
}

.wb-process-shape.document {
    width: 120px;
    height: 60px;
    border-radius: 2px;
    position: relative;
    border-bottom: none;
}

.wb-process-shape.document::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 0;
    right: 0;
    height: 16px;
    background: var(--wb-panel);
    border: 2px solid var(--wb-accent);
    border-top: none;
    border-radius: 0 0 50% 50% / 0 0 100% 100%;
}

.wb-process-shape.cylinder {
    width: 100px;
    height: 80px;
    border-radius: 0;
    border: none;
    background: transparent;
    position: relative;
}

.wb-process-shape.cylinder::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 20px;
    background: var(--wb-panel);
    border: 2px solid var(--wb-accent);
    border-radius: 50%;
    z-index: 2;
}

.wb-process-shape.cylinder::after {
    content: '';
    position: absolute;
    top: 10px;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--wb-panel);
    border: 2px solid var(--wb-accent);
    border-top: none;
    border-radius: 0 0 50% 50% / 0 0 30% 30%;
}

/* Connection Points */
.wb-connection-point {
    position: absolute;
    width: 12px;
    height: 12px;
    background: var(--wb-accent);
    border: 2px solid white;
    border-radius: 50%;
    cursor: crosshair;
    opacity: 0;
    transition: opacity 0.15s, transform 0.15s;
    z-index: 100;
}

.wb-connection-point:hover {
    transform: translateX(-50%) scale(1.3);
    background: #5fc484;
}

.wb-connection-point.top:hover { transform: translateX(-50%) scale(1.3); }
.wb-connection-point.bottom:hover { transform: translateX(-50%) scale(1.3); }
.wb-connection-point.left:hover { transform: translateY(-50%) scale(1.3); }
.wb-connection-point.right:hover { transform: translateY(-50%) scale(1.3); }

.wb-element:hover .wb-connection-point,
.wb-element.selected .wb-connection-point {
    opacity: 1;
}

/* Show all connection points when in connect mode */
.wb-container.connect-mode .wb-connection-point {
    opacity: 0.7;
}

.wb-container.connect-mode .wb-element:hover .wb-connection-point {
    opacity: 1;
}

.wb-connection-point.top { top: -6px; left: 50%; transform: translateX(-50%); }
.wb-connection-point.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); }
.wb-connection-point.left { left: -6px; top: 50%; transform: translateY(-50%); }
.wb-connection-point.right { right: -6px; top: 50%; transform: translateY(-50%); }

/* Diamond connection points - position at corners and counter-rotate */
.wb-process-shape.diamond .wb-connection-point.top {
    top: -21%;
    left: 50%;
    transform: rotate(-45deg) translateX(-50%);
}
.wb-process-shape.diamond .wb-connection-point.bottom {
    bottom: -21%;
    top: auto;
    left: 50%;
    transform: rotate(-45deg) translateX(-50%);
}
.wb-process-shape.diamond .wb-connection-point.left {
    left: -21%;
    top: 50%;
    transform: rotate(-45deg) translateY(-50%);
}
.wb-process-shape.diamond .wb-connection-point.right {
    right: -21%;
    left: auto;
    top: 50%;
    transform: rotate(-45deg) translateY(-50%);
}

/* Diamond connection point hover states */
.wb-process-shape.diamond .wb-connection-point.top:hover,
.wb-process-shape.diamond .wb-connection-point.bottom:hover {
    transform: rotate(-45deg) translateX(-50%) scale(1.3);
}
.wb-process-shape.diamond .wb-connection-point.left:hover,
.wb-process-shape.diamond .wb-connection-point.right:hover {
    transform: rotate(-45deg) translateY(-50%) scale(1.3);
}

/* Temporary connection line while dragging */
.wb-temp-connection {
    stroke: var(--wb-accent);
    stroke-width: 2;
    stroke-dasharray: 5, 5;
    fill: none;
    pointer-events: none;
}

/* Causal (If-Then) Connections */
.wb-causal-connection {
    stroke: #e89547 !important;
    stroke-width: 3 !important;
}

.wb-connection-label {
    font-size: 10px;
    font-weight: 600;
    fill: #e89547;
    pointer-events: none;
}

.wb-connection-label.if-label {
    fill: #e89547;
}

.wb-connection-label.then-label {
    fill: #47a5e8;
}

/* Connector Style Selector */
.wb-connector-styles {
    display: none;
    gap: 2px;
    margin-left: 4px;
    padding: 0 4px;
    border-left: 1px solid var(--wb-border);
}

.wb-container.connect-mode .wb-connector-styles {
    display: flex;
}

.wb-conn-style-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 4px;
    color: var(--wb-text-dim);
    cursor: pointer;
    transition: all 0.15s;
    padding: 0;
}

.wb-conn-style-btn:hover {
    background: rgba(74, 159, 110, 0.15);
    border-color: var(--wb-border);
    color: var(--wb-text);
}

.wb-conn-style-btn.active {
    background: rgba(74, 159, 110, 0.25);
    border-color: var(--wb-accent);
    color: var(--wb-accent);
}

.wb-conn-style-btn svg { width: 18px; height: 18px; }

/* Logic Gate Elements */
.wb-gate {
    min-width: 60px;
    min-height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--wb-panel);
    border: 2px solid #a29bfe;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 700;
    color: #a29bfe;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.wb-gate.and-gate {
    border-color: #a29bfe;
    color: #a29bfe;
    border-radius: 8px 30px 30px 8px;
}

.wb-gate.or-gate {
    border-color: #ff7eb9;
    color: #ff7eb9;
    border-radius: 30px;
}

.wb-gate::before {
    content: attr(data-gate-type);
}

/* Causal tool indicator */
.wb-tool-btn.causal-mode {
    background: rgba(232, 149, 71, 0.25) !important;
    border-color: #e89547 !important;
    color: #e89547 !important;
}

.wb-container.causal-mode .wb-connection-point {
    background: #e89547;
}

/* VSM Specific */
.wb-vsm-process {
    width: 100px;
    height: 80px;
    background: var(--wb-panel);
    border: 2px solid #47a5e8;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
}

.wb-vsm-process .title {
    padding: 6px;
    background: #47a5e8;
    color: white;
    font-size: 11px;
    font-weight: 600;
    text-align: center;
}

.wb-vsm-process .metrics {
    flex: 1;
    padding: 6px;
    font-size: 10px;
    color: var(--wb-text-dim);
}

.wb-vsm-inventory {
    width: 60px;
    height: 60px;
    background: #e89547;
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 600;
    clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
}

/* Text/Label */
.wb-text {
    padding: 8px 12px;
    font-size: 14px;
    color: var(--wb-text);
    background: transparent;
    border: none;
    min-width: 50px;
}

.wb-text[contenteditable="true"]:focus {
    outline: 1px dashed var(--wb-accent);
}

/* Context Menu */
.wb-context-menu {
    position: fixed;
    background: var(--wb-panel);
    border: 1px solid var(--wb-border);
    border-radius: 8px;
    padding: 6px 0;
    min-width: 160px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.4);
    z-index: 1000;
    display: none;
}

.wb-context-menu.active { display: block; }

.wb-context-item {
    padding: 8px 16px;
    font-size: 12px;
    color: var(--wb-text);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 10px;
}

.wb-context-item:hover {
    background: rgba(74, 159, 110, 0.2);
}

.wb-context-item svg {
    width: 14px;
    height: 14px;
    color: var(--wb-text-dim);
}

.wb-context-sep {
    height: 1px;
    background: var(--wb-border);
    margin: 4px 0;
}

/* Property Panel */
.wb-properties {
    width: 240px;
    background: var(--wb-panel);
    border-left: 1px solid var(--wb-border);
    padding: 12px;
    overflow-y: auto;
    display: none;
}

.wb-properties.active { display: block; }

.wb-prop-title {
    font-size: 12px;
    font-weight: 600;
    color: var(--wb-accent);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.wb-prop-group {
    margin-bottom: 16px;
}

.wb-prop-label {
    font-size: 10px;
    color: var(--wb-text-dim);
    margin-bottom: 4px;
    text-transform: uppercase;
}

.wb-prop-input {
    width: 100%;
    padding: 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--wb-border);
    border-radius: 4px;
    color: var(--wb-text);
    font-size: 12px;
}

.wb-prop-input:focus {
    outline: none;
    border-color: var(--wb-accent);
}

/* Mini-map */
.wb-minimap {
    position: absolute;
    bottom: 12px;
    right: 12px;
    width: 150px;
    height: 100px;
    background: rgba(18, 26, 18, 0.9);
    border: 1px solid var(--wb-border);
    border-radius: 6px;
    overflow: hidden;
}

.wb-minimap-viewport {
    position: absolute;
    border: 1px solid var(--wb-accent);
    background: rgba(74, 159, 110, 0.2);
}

/* Keyboard Shortcuts Help */
.wb-shortcuts {
    position: absolute;
    bottom: 12px;
    left: 12px;
    font-size: 10px;
    color: var(--wb-text-dim);
    opacity: 0.6;
}

.wb-shortcuts kbd {
    padding: 2px 5px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    margin-right: 4px;
}

/* Fishbone Diagram */
.wb-fishbone {
    position: relative;
    min-width: 900px;
    min-height: 500px;
}

.wb-fishbone-spine {
    position: absolute;
    left: 50px;
    right: 120px;
    top: 50%;
    height: 4px;
    background: var(--wb-accent);
    transform: translateY(-50%);
}

.wb-fishbone-head {
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 120px;
    height: 60px;
    background: var(--wb-accent);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 14px;
    cursor: text;
}

.wb-fishbone-bone {
    position: absolute;
    width: 3px;
    background: var(--wb-accent);
    transform-origin: bottom center;
}

.wb-fishbone-bone.top {
    transform: rotate(-30deg);
}

.wb-fishbone-bone.bottom {
    transform: rotate(30deg);
}

.wb-fishbone-category {
    position: absolute;
    padding: 6px 12px;
    background: rgba(74, 159, 110, 0.2);
    border: 2px solid var(--wb-accent);
    border-radius: 4px;
    font-weight: 600;
    font-size: 12px;
    color: var(--wb-accent);
    white-space: nowrap;
    cursor: text;
}

.wb-fishbone-causes {
    position: absolute;
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.wb-fishbone-causes.top {
    bottom: 100%;
    margin-bottom: 8px;
}

.wb-fishbone-causes.bottom {
    top: 100%;
    margin-top: 8px;
}

.wb-fishbone-cause {
    position: relative;
    padding: 4px 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--wb-border);
    border-radius: 3px;
    font-size: 11px;
    color: var(--wb-text);
    cursor: text;
    white-space: nowrap;
}

.wb-fishbone-cause::before {
    content: '';
    position: absolute;
    width: 20px;
    height: 2px;
    background: var(--wb-accent);
    opacity: 0.5;
}

.wb-fishbone-causes.top .wb-fishbone-cause::before {
    bottom: -6px;
    left: 50%;
    transform: translateX(-50%);
}

.wb-fishbone-causes.bottom .wb-fishbone-cause::before {
    top: -6px;
    left: 50%;
    transform: translateX(-50%);
}

.wb-fishbone-add {
    padding: 2px 8px;
    background: transparent;
    border: 1px dashed var(--wb-border);
    border-radius: 3px;
    font-size: 10px;
    color: var(--wb-text-dim);
    cursor: pointer;
    transition: all 0.15s;
}

.wb-fishbone-add:hover {
    border-color: var(--wb-accent);
    color: var(--wb-accent);
}

/* ============================================================================
   COLLABORATION & VOTING
   ============================================================================ */

.wb-room-code {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 12px;
    background: rgba(74, 159, 110, 0.15);
    border: 1px solid var(--wb-accent);
    border-radius: 4px;
    font-family: monospace;
    font-size: 14px;
    font-weight: 600;
    color: var(--wb-accent);
    cursor: pointer;
    transition: all 0.15s;
}

.wb-room-code:hover {
    background: rgba(74, 159, 110, 0.25);
}

.wb-participants {
    display: flex;
    align-items: center;
    gap: -6px;
    margin-left: 8px;
}

.wb-participant {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid var(--wb-panel);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 600;
    color: white;
    margin-left: -6px;
    position: relative;
    cursor: default;
}

.wb-participant:first-child {
    margin-left: 0;
}

.wb-participant[title]::after {
    content: attr(title);
    position: absolute;
    bottom: -24px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--wb-panel);
    border: 1px solid var(--wb-border);
    padding: 2px 6px;
    font-size: 10px;
    white-space: nowrap;
    border-radius: 3px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s;
    z-index: 100;
}

.wb-participant:hover::after {
    opacity: 1;
}

.wb-vote-btn.active {
    background: rgba(232, 149, 71, 0.25) !important;
    border-color: #e89547 !important;
    color: #e89547 !important;
}

.wb-votes-remaining {
    font-size: 11px;
    color: #e89547;
    padding: 4px 8px;
    background: rgba(232, 149, 71, 0.15);
    border-radius: 4px;
}

/* Vote dots on elements */
.wb-vote-count {
    position: absolute;
    top: -10px;
    right: -10px;
    min-width: 22px;
    height: 22px;
    background: #e89547;
    color: white;
    border-radius: 11px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: 600;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    z-index: 10;
}

.wb-vote-count.zero {
    display: none;
}

/* Voting overlay on elements */
.wb-element.voting-mode {
    cursor: pointer;
}

.wb-element.voting-mode:hover::after {
    content: '+1';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(232, 149, 71, 0.9);
    color: white;
    padding: 8px 16px;
    border-radius: 4px;
    font-weight: 600;
    pointer-events: none;
}

.wb-element.voted::after {
    content: '✓ voted';
    background: rgba(74, 159, 110, 0.9);
}

/* Cursor presence */
.wb-cursor {
    position: absolute;
    pointer-events: none;
    z-index: 1000;
    transition: left 0.1s, top 0.1s;
}

.wb-cursor-pointer {
    width: 12px;
    height: 18px;
}

.wb-cursor-label {
    position: absolute;
    top: 18px;
    left: 8px;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: 500;
    color: white;
    white-space: nowrap;
}

/* Sync indicator */
.wb-sync-status {
    position: fixed;
    bottom: 12px;
    right: 12px;
    padding: 6px 12px;
    background: var(--wb-panel);
    border: 1px solid var(--wb-border);
    border-radius: 4px;
    font-size: 11px;
    color: var(--wb-text-dim);
    z-index: 100;
    display: flex;
    align-items: center;
    gap: 6px;
}

.wb-sync-status.syncing {
    border-color: #e89547;
    color: #e89547;
}

.wb-sync-status.synced {
    border-color: var(--wb-accent);
    color: var(--wb-accent);
}

.wb-sync-status.error {
    border-color: #e85747;
    color: #e85747;
}

.wb-sync-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: currentColor;
}

.wb-sync-status.syncing .wb-sync-dot {
    animation: pulse 1s infinite;
}
</style>
{% endblock %}

{% block content %}
<div class="wb-container">
    <!-- Toolbar -->
    <div class="wb-toolbar">
        <div class="wb-toolbar-group">
            <button class="wb-tool-btn active" data-tool="select" title="Select (V)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/>
                </svg>
            </button>
            <button class="wb-tool-btn" data-tool="pan" title="Pan (Space+Drag)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M15 19l-3 3-3-3M19 9l3 3-3 3"/>
                </svg>
            </button>
            <button class="wb-tool-btn" data-tool="connect" title="Connect (C)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                    <polyline points="15 3 21 3 21 9"/>
                    <line x1="10" y1="14" x2="21" y2="3"/>
                </svg>
            </button>
            <button class="wb-tool-btn" data-tool="causal" title="If-Then Connection (I)">
                <svg viewBox="0 0 24 24" fill="none" stroke="#e89547" stroke-width="2">
                    <circle cx="5" cy="12" r="3"/>
                    <circle cx="19" cy="12" r="3"/>
                    <path d="M8 12h8" stroke-width="3"/>
                    <polyline points="14 9 17 12 14 15" fill="none"/>
                </svg>
            </button>
            <div class="wb-connector-styles">
                <button class="wb-conn-style-btn" data-conn-style="straight" title="Straight connector">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="4" y1="20" x2="20" y2="4"/>
                        <polygon points="20 4, 14 6, 18 10" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <button class="wb-conn-style-btn active" data-conn-style="orthogonal" title="Right-angle connector (default)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="4,20 4,12 20,12 20,4" fill="none"/>
                        <polygon points="20 4, 17 8, 23 8" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <button class="wb-conn-style-btn" data-conn-style="curved" title="Curved connector">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M4 20 C4 12, 20 12, 20 4" fill="none"/>
                        <polygon points="20 4, 17 8, 23 8" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
            </div>
        </div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn" data-tool="postit" title="Post-it Note (P)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                </svg>
            </button>
            <button class="wb-tool-btn" data-tool="text" title="Text (T)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polyline points="4 7 4 4 20 4 20 7"/>
                    <line x1="9" y1="20" x2="15" y2="20"/>
                    <line x1="12" y1="4" x2="12" y2="20"/>
                </svg>
            </button>
            <button class="wb-tool-btn" data-tool="group" title="Group/Affinity (G)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke-dasharray="4 2"/>
                </svg>
            </button>
        </div>

        <div class="wb-toolbar-group">
            <span class="wb-toolbar-label">Color</span>
            <button class="wb-color-btn active" data-color="yellow" style="background: #feff9c;" title="Yellow"></button>
            <button class="wb-color-btn" data-color="green" style="background: #7afcff;" title="Cyan"></button>
            <button class="wb-color-btn" data-color="pink" style="background: #ff7eb9;" title="Pink"></button>
            <button class="wb-color-btn" data-color="orange" style="background: #ff9f43;" title="Orange"></button>
            <button class="wb-color-btn" data-color="blue" style="background: #74b9ff;" title="Blue"></button>
            <button class="wb-color-btn" data-color="purple" style="background: #a29bfe;" title="Purple"></button>
        </div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn" onclick="undo()" title="Undo (Ctrl+Z)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 10h10a5 5 0 0 1 5 5v2"/>
                    <polyline points="3 10 7 6"/>
                    <polyline points="3 10 7 14"/>
                </svg>
            </button>
            <button class="wb-tool-btn" onclick="redo()" title="Redo (Ctrl+Shift+Z)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 10H11a5 5 0 0 0-5 5v2"/>
                    <polyline points="21 10 17 6"/>
                    <polyline points="21 10 17 14"/>
                </svg>
            </button>
        </div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn" onclick="zoomIn()" title="Zoom In (+)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                    <line x1="11" y1="8" x2="11" y2="14"/>
                    <line x1="8" y1="11" x2="14" y2="11"/>
                </svg>
            </button>
            <span class="wb-zoom-display" id="zoom-display">100%</span>
            <button class="wb-tool-btn" onclick="zoomOut()" title="Zoom Out (-)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"/>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"/>
                    <line x1="8" y1="11" x2="14" y2="11"/>
                </svg>
            </button>
            <button class="wb-tool-btn" onclick="zoomReset()" title="Reset Zoom (0)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                </svg>
            </button>
        </div>

        <div style="flex:1;"></div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn" onclick="exportCausalAsHypotheses()" title="Export If-Then as Hypotheses" style="color: #e89547;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="12" r="3"/>
                    <path d="M9 12h6" stroke-width="2"/>
                    <polyline points="13 9 16 12 13 15"/>
                    <path d="M18 6v-2a2 2 0 0 1 2-2h1"/>
                </svg>
            </button>
            <button class="wb-tool-btn" onclick="exportBoard('png')" title="Export as PNG">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            </button>
            <button class="wb-tool-btn" onclick="exportBoardJSON()" title="Export as JSON (backup)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                    <polyline points="14 2 14 8 20 8"/>
                    <line x1="9" y1="15" x2="15" y2="15"/>
                </svg>
            </button>
            <input type="file" id="import-file" accept=".json" style="display:none" onchange="importBoardJSON(event)">
            <button class="wb-tool-btn" onclick="document.getElementById('import-file').click()" title="Import JSON">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
            </button>
            <button class="wb-tool-btn" onclick="saveBoard()" title="Save (Ctrl+S)">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                    <polyline points="17 21 17 13 7 13 7 21"/>
                    <polyline points="7 3 7 8 15 8"/>
                </svg>
            </button>
        </div>

        <!-- Collaboration controls -->
        <div class="wb-toolbar-group wb-collab-controls" id="collab-controls" style="display:none;">
            <div class="wb-room-code" id="room-code-display" onclick="copyRoomLink()" title="Click to copy link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/>
                </svg>
                <span id="room-code-text">------</span>
            </div>
            <div class="wb-participants" id="participants-list"></div>
        </div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn wb-vote-btn" id="vote-toggle" onclick="toggleVoting()" title="Toggle Dot Voting" style="display:none;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"/>
                    <circle cx="12" cy="12" r="3" fill="currentColor"/>
                </svg>
            </button>
            <span class="wb-votes-remaining" id="votes-remaining" style="display:none;">3 votes</span>
        </div>

        <div class="wb-toolbar-group wb-project-group">
            <select id="project-select" class="wb-project-select" title="Link to project">
                <option value="">No project</option>
            </select>
            <a href="#" id="project-link" class="wb-project-link" style="display:none" title="Open project">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                    <polyline points="15 3 21 3 21 9"/>
                    <line x1="10" y1="14" x2="21" y2="3"/>
                </svg>
            </a>
        </div>

        <div class="wb-toolbar-group">
            <button class="wb-tool-btn" onclick="shareBoard()" title="Share / Create Room">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Main Area -->
    <div class="wb-main">
        <!-- Sidebar -->
        <div class="wb-sidebar">
            <div class="wb-sidebar-section">
                <div class="wb-sidebar-header">
                    <span>Shapes</span>
                </div>
                <div class="wb-sidebar-content">
                    <div class="wb-shape-grid">
                        <div class="wb-shape-item" draggable="true" data-shape="rectangle">
                            <svg viewBox="0 0 40 30"><rect x="2" y="2" width="36" height="26" fill="none" stroke="currentColor" stroke-width="2" rx="2"/></svg>
                            <span>Process</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="diamond">
                            <svg viewBox="0 0 40 40"><polygon points="20,2 38,20 20,38 2,20" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Decision</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="oval">
                            <svg viewBox="0 0 40 25"><ellipse cx="20" cy="12.5" rx="18" ry="10" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Terminal</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="parallelogram">
                            <svg viewBox="0 0 40 25"><polygon points="8,2 38,2 32,23 2,23" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Data</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="document">
                            <svg viewBox="0 0 40 35"><path d="M4,2 L36,2 L36,28 Q20,35 4,28 Z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Document</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="cylinder">
                            <svg viewBox="0 0 40 40"><ellipse cx="20" cy="8" rx="16" ry="6" fill="none" stroke="currentColor" stroke-width="2"/><path d="M4,8 L4,32" stroke="currentColor" stroke-width="2"/><path d="M36,8 L36,32" stroke="currentColor" stroke-width="2"/><ellipse cx="20" cy="32" rx="16" ry="6" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                            <span>Database</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="gate-and">
                            <svg viewBox="0 0 40 30"><path d="M4,4 L20,4 Q36,4 36,15 Q36,26 20,26 L4,26 Z" fill="none" stroke="#a29bfe" stroke-width="2"/><text x="14" y="19" font-size="10" fill="#a29bfe" font-weight="bold">AND</text></svg>
                            <span>AND Gate</span>
                        </div>
                        <div class="wb-shape-item" draggable="true" data-shape="gate-or">
                            <svg viewBox="0 0 40 30"><path d="M4,4 Q12,15 4,26 Q20,20 36,15 Q20,10 4,4" fill="none" stroke="#ff7eb9" stroke-width="2"/><text x="12" y="19" font-size="10" fill="#ff7eb9" font-weight="bold">OR</text></svg>
                            <span>OR Gate</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="wb-sidebar-section">
                <div class="wb-sidebar-header">
                    <span>Templates</span>
                </div>
                <div class="wb-sidebar-content">
                    <div class="wb-template-item" onclick="loadTemplate('affinity')">
                        <div class="icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/>
                                <rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Affinity Diagram</div>
                            <div class="desc">Group ideas into themes</div>
                        </div>
                    </div>
                    <div class="wb-template-item" onclick="loadTemplate('interrelationship')">
                        <div class="icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="12" cy="5" r="3"/><circle cx="5" cy="19" r="3"/><circle cx="19" cy="19" r="3"/>
                                <path d="M12 8v4M8 17l2-4M16 17l-2-4"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Interrelationship</div>
                            <div class="desc">Map cause-effect relations</div>
                        </div>
                    </div>
                    <div class="wb-template-item" onclick="loadTemplate('process')">
                        <div class="icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="9" width="6" height="6" rx="1"/><rect x="9" y="9" width="6" height="6" rx="1"/>
                                <rect x="16" y="9" width="6" height="6" rx="1"/><path d="M8 12h1M15 12h1"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Process Map</div>
                            <div class="desc">Document workflow steps</div>
                        </div>
                    </div>
                    <div class="wb-template-item" onclick="loadTemplate('vsm')">
                        <div class="icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M4 4h4v6H4zM10 4h4v6h-4zM16 4h4v6h-4z"/>
                                <path d="M6 10v4M12 10v4M18 10v4"/>
                                <path d="M2 18h20"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Value Stream Map</div>
                            <div class="desc">Analyze flow & waste</div>
                        </div>
                    </div>
                    <div class="wb-template-item" onclick="loadTemplate('fishbone')">
                        <div class="icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M2 12h20M22 12l-4-4M22 12l-4 4"/>
                                <path d="M6 6l4 6M6 18l4-6M12 4l2 8M12 20l2-8"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Fishbone / Ishikawa</div>
                            <div class="desc">Cause-and-effect analysis</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="wb-sidebar-section">
                <div class="wb-sidebar-header">
                    <span>Convert</span>
                </div>
                <div class="wb-sidebar-content">
                    <div class="wb-template-item" onclick="convertAffinityToIR()">
                        <div class="icon" style="background:rgba(71,165,232,0.2);color:#47a5e8;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 12h14M12 5l7 7-7 7"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Affinity → IR</div>
                            <div class="desc">Groups become factors</div>
                        </div>
                    </div>
                    <div class="wb-template-item" onclick="analyzeIR()">
                        <div class="icon" style="background:rgba(232,149,71,0.2);color:#e89547;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 3v18h18"/>
                                <path d="M7 12l4-4 4 4 4-4"/>
                            </svg>
                        </div>
                        <div class="info">
                            <div class="name">Analyze IR</div>
                            <div class="desc">Count arrows (driver/outcome)</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="wb-sidebar-section" style="flex:1;overflow-y:auto;">
                <div class="wb-sidebar-header">
                    <span>Boards</span>
                    <button class="wb-tool-btn" style="width:24px;height:24px;" onclick="newBoard()" title="New Board">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:14px;height:14px;">
                            <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
                        </svg>
                    </button>
                </div>
                <div class="wb-sidebar-content" id="boards-list">
                    <!-- Saved boards will be listed here -->
                    <div style="color:var(--wb-text-dim);font-size:11px;text-align:center;padding:20px;">
                        No saved boards yet
                    </div>
                </div>
            </div>
        </div>

        <!-- Canvas -->
        <div class="wb-canvas-container" id="canvas-container">
            <div class="wb-canvas" id="canvas">
                <svg class="wb-connections" id="connections-svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="12" markerHeight="8" refX="11" refY="4" orient="auto">
                            <polygon points="0 0, 12 4, 0 8" fill="#4a9f6e"/>
                        </marker>
                        <marker id="arrowhead-causal" markerWidth="14" markerHeight="10" refX="13" refY="5" orient="auto">
                            <polygon points="0 0, 14 5, 0 10" fill="#e89547"/>
                        </marker>
                    </defs>
                </svg>
                <!-- Elements will be created here -->
            </div>

            <div class="wb-shortcuts">
                <kbd>V</kbd> Select <kbd>P</kbd> Post-it <kbd>C</kbd> Connect <kbd>I</kbd> If-Then <kbd>Del</kbd> Delete <kbd>Space</kbd> Pan <kbd>Ctrl+Z</kbd> Undo
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="wb-properties" id="properties-panel">
            <div class="wb-prop-title">Properties</div>
            <div id="properties-content">
                <p style="color:var(--wb-text-dim);font-size:11px;">Select an element to edit its properties</p>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="wb-context-menu" id="context-menu">
        <div class="wb-context-item" onclick="duplicateSelected()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
            </svg>
            Duplicate
        </div>
        <div class="wb-context-item" onclick="bringToFront()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="18 15 12 9 6 15"/>
            </svg>
            Bring to Front
        </div>
        <div class="wb-context-item" onclick="sendToBack()">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
            Send to Back
        </div>
        <div class="wb-context-sep"></div>
        <div class="wb-context-item" onclick="deleteSelected()" style="color:#e85747;">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
            </svg>
            Delete
        </div>
    </div>
</div>

<script>
// ============================================================================
// WHITEBOARD - Visual Mapping Tool
// ============================================================================

let currentTool = 'select';
let currentColor = 'yellow';
let connectorStyle = 'orthogonal';
let selectedElement = null;
let elements = [];
let connections = [];
let zoom = 1;
let panX = 0, panY = 0;
let isPanning = false;
let isConnecting = false;
let connectionStart = null;
let elementIdCounter = 0;
let isDragging = false;
let didDrag = false;
let dragOffset = { x: 0, y: 0 };
let currentProjectId = null;

// Undo/Redo history
let history = [];
let historyIndex = -1;
const MAX_HISTORY = 50;

const canvas = document.getElementById('canvas');
const canvasContainer = document.getElementById('canvas-container');
const connectionsSvg = document.getElementById('connections-svg');
const contextMenu = document.getElementById('context-menu');

// ============================================================================
// Undo/Redo System
// ============================================================================

function saveState() {
    // Clone current state
    const state = {
        elements: JSON.parse(JSON.stringify(elements)),
        connections: JSON.parse(JSON.stringify(connections)),
        elementIdCounter
    };

    // Remove any future states if we're in the middle of history
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }

    // Add new state
    history.push(state);

    // Limit history size
    if (history.length > MAX_HISTORY) {
        history.shift();
    } else {
        historyIndex++;
    }
}

function restoreState(state) {
    // Clear canvas
    canvas.querySelectorAll('.wb-element').forEach(el => el.remove());
    connectionsSvg.querySelectorAll('path').forEach(p => p.remove());

    // Restore data
    elements = [];
    connections = state.connections;
    elementIdCounter = state.elementIdCounter;
    selectedElement = null;

    // Recreate elements
    state.elements.forEach(el => {
        createElement(el.type, el.x, el.y, el, true); // true = skip saving state
    });

    // Render connections
    setTimeout(() => renderConnections(), 10);
}

function undo() {
    if (historyIndex > 0) {
        historyIndex--;
        restoreState(history[historyIndex]);
    }
}

function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        restoreState(history[historyIndex]);
    }
}

// ============================================================================
// Tool Selection
// ============================================================================

document.querySelectorAll('.wb-tool-btn[data-tool]').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.wb-tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentTool = btn.dataset.tool;

        // Set cursor based on tool
        if (currentTool === 'pan') {
            canvasContainer.style.cursor = 'grab';
        } else if (currentTool === 'connect' || currentTool === 'causal') {
            canvasContainer.style.cursor = 'crosshair';
        } else {
            canvasContainer.style.cursor = 'default';
        }

        // Toggle causal mode class for styling
        document.querySelector('.wb-container').classList.toggle('causal-mode', currentTool === 'causal');

        // Toggle connect mode class for showing connection points
        const container = document.querySelector('.wb-container');
        if (currentTool === 'connect' || currentTool === 'causal') {
            container.classList.add('connect-mode');
        } else {
            container.classList.remove('connect-mode');
        }
    });
});

// Connector style selection
document.querySelectorAll('.wb-conn-style-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.wb-conn-style-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        connectorStyle = btn.dataset.connStyle;
    });
});

document.querySelectorAll('.wb-color-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.wb-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentColor = btn.dataset.color;
        console.log('Color changed to:', currentColor);

        // Update selected element color
        if (selectedElement && selectedElement.classList.contains('wb-postit')) {
            saveState();
            // Remove old color classes
            ['yellow', 'green', 'pink', 'orange', 'blue', 'purple'].forEach(c => {
                selectedElement.classList.remove(c);
            });
            // Add new color
            selectedElement.classList.add(currentColor);
            updateElementData(selectedElement.dataset.id, { color: currentColor });
        }
    });
});

// ============================================================================
// Element Creation
// ============================================================================

function createElement(type, x, y, options = {}, skipHistory = false) {
    if (!skipHistory) saveState();
    const id = options.id || `el-${++elementIdCounter}`;
    const el = document.createElement('div');
    el.className = 'wb-element';
    el.dataset.id = id;
    el.dataset.type = type;
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;

    const elementData = {
        id,
        type,
        x,
        y,
        ...options
    };

    switch (type) {
        case 'postit':
            const postitColor = options.color || currentColor;
            el.classList.add('wb-postit', postitColor);
            el.contentEditable = 'true';
            el.textContent = options.text || 'Double-click to edit';
            elementData.color = postitColor;
            elementData.text = options.text || '';
            console.log('Created postit with color:', postitColor, 'classes:', el.className);
            break;

        case 'text':
            el.className += ' wb-text';
            el.contentEditable = 'true';
            el.textContent = options.text || 'Text';
            elementData.text = options.text || 'Text';
            break;

        case 'group':
            el.className += ' wb-group';
            el.innerHTML = `<div class="wb-group-header" contenteditable="true">${options.title || 'Group Title'}</div>`;
            el.style.width = `${options.width || 250}px`;
            el.style.height = `${options.height || 200}px`;
            elementData.title = options.title || 'Group Title';
            elementData.width = options.width || 250;
            elementData.height = options.height || 200;
            break;

        case 'rectangle':
        case 'diamond':
        case 'oval':
        case 'parallelogram':
            el.className += ` wb-process-shape ${type}`;
            el.innerHTML = `<span contenteditable="true">${options.text || 'Step'}</span>`;
            elementData.text = options.text || 'Step';
            break;

        case 'vsm-process':
            el.className += ' wb-vsm-process';
            el.innerHTML = `
                <div class="title" contenteditable="true">${options.title || 'Process'}</div>
                <div class="metrics">
                    <div>CT: ${options.ct || '0'}</div>
                    <div>C/O: ${options.co || '0'}</div>
                </div>
            `;
            break;

        case 'vsm-inventory':
            el.className += ' wb-vsm-inventory';
            el.innerHTML = `<div>${options.qty || '0'}</div><div>pcs</div>`;
            break;

        case 'document':
            el.className += ' wb-process-shape document';
            el.innerHTML = `<span contenteditable="true">${options.text || 'Document'}</span>`;
            elementData.text = options.text || 'Document';
            break;

        case 'cylinder':
            el.className += ' wb-process-shape cylinder';
            el.innerHTML = `<span contenteditable="true" style="position:relative;z-index:3;">${options.text || 'Database'}</span>`;
            elementData.text = options.text || 'Database';
            break;

        case 'gate-and':
            el.className += ' wb-gate and-gate';
            el.dataset.gateType = 'AND';
            elementData.gateType = 'AND';
            break;

        case 'gate-or':
            el.className += ' wb-gate or-gate';
            el.dataset.gateType = 'OR';
            elementData.gateType = 'OR';
            break;

        case 'fishbone':
            // Fishbone is created separately, but handle restore
            el.className += ' wb-fishbone';
            elementData.effect = options.effect || 'Hypothesis / Effect';
            elementData.categories = options.categories || [];
            renderFishbone(el, elementData);
            // Skip adding connection points for fishbone
            canvas.appendChild(el);
            elements.push(elementData);
            return el;
    }

    // Add connection points
    addConnectionPoints(el);

    // Event listeners
    el.addEventListener('mousedown', (e) => onElementMouseDown(e, el));
    el.addEventListener('dblclick', (e) => onElementDoubleClick(e, el));
    el.addEventListener('contextmenu', (e) => onElementContextMenu(e, el));

    canvas.appendChild(el);
    elements.push(elementData);

    return el;
}

function addConnectionPoints(el) {
    ['top', 'bottom', 'left', 'right'].forEach(pos => {
        const point = document.createElement('div');
        point.className = `wb-connection-point ${pos}`;
        point.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startConnection(e, el, pos);
        });
        point.addEventListener('mouseup', (e) => {
            e.stopPropagation();
            if (isConnecting && connectionStart) {
                finishConnection(el, pos);
            }
        });
        point.addEventListener('mouseenter', (e) => {
            if (isConnecting) {
                point.style.transform = pos === 'top' || pos === 'bottom'
                    ? 'translateX(-50%) scale(1.5)'
                    : 'translateY(-50%) scale(1.5)';
                point.style.background = '#5fc484';
            }
        });
        point.addEventListener('mouseleave', (e) => {
            point.style.transform = '';
            point.style.background = '';
        });
        el.appendChild(point);
    });
}

// ============================================================================
// Element Interaction
// ============================================================================

function onElementMouseDown(e, el) {
    if (e.target.classList.contains('wb-connection-point')) return;
    if (el.contentEditable === 'true' && document.activeElement === el) return;

    e.stopPropagation();

    selectElement(el);

    if (currentTool === 'select') {
        isDragging = true;
        didDrag = false;
        const rect = el.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        el.style.cursor = 'grabbing';
    }
}

function onElementDoubleClick(e, el) {
    if (el.contentEditable === 'true') {
        el.focus();
        // Select all text
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
    }
}

function onElementContextMenu(e, el) {
    e.preventDefault();
    selectElement(el);
    showContextMenu(e.clientX, e.clientY);
}

function selectElement(el) {
    if (selectedElement) {
        selectedElement.classList.remove('selected');
    }
    selectedElement = el;
    el.classList.add('selected');
    showProperties(el);
}

function deselectAll() {
    if (selectedElement) {
        selectedElement.classList.remove('selected');
        selectedElement = null;
    }
    hideContextMenu();
    document.getElementById('properties-panel').classList.remove('active');
}

// ============================================================================
// Connections
// ============================================================================

let tempConnectionLine = null;

function startConnection(e, el, position) {
    e.stopPropagation();
    e.preventDefault();
    isConnecting = true;
    connectionStart = { element: el, position };
    canvasContainer.style.cursor = 'crosshair';

    // Create temporary connection line
    tempConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    tempConnectionLine.classList.add('wb-temp-connection');
    const startPoint = getConnectionPoint(el, position);
    connectionStart.startPoint = startPoint;
    tempConnectionLine.setAttribute('d', `M ${startPoint.x} ${startPoint.y} L ${startPoint.x} ${startPoint.y}`);
    connectionsSvg.appendChild(tempConnectionLine);

    console.log('Started connection from', el.dataset.id, position);
}

function updateTempConnection(e) {
    if (!isConnecting || !tempConnectionLine || !connectionStart) return;

    const rect = canvasContainer.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / zoom;
    const y = (e.clientY - rect.top - panY) / zoom;

    const from = connectionStart.startPoint;
    const cursor = { x, y, dir: { x: 0, y: 0 } };

    let d;
    if (connectorStyle === 'straight') {
        d = calculateStraightPath(from, cursor);
    } else if (connectorStyle === 'orthogonal') {
        // For temp line, infer a direction toward the cursor
        const dx = x - from.x;
        const dy = y - from.y;
        if (Math.abs(dx) > Math.abs(dy)) {
            cursor.dir = { x: dx > 0 ? -1 : 1, y: 0 };
        } else {
            cursor.dir = { x: 0, y: dy > 0 ? -1 : 1 };
        }
        d = calculateOrthogonalPath(from, cursor);
    } else {
        // Curved — simple bezier to cursor
        const dx = x - from.x;
        const dy = y - from.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const cpDist = Math.min(100, Math.max(30, dist * 0.4));
        const cp1x = from.x + from.dir.x * cpDist;
        const cp1y = from.y + from.dir.y * cpDist;
        d = `M ${from.x} ${from.y} C ${cp1x} ${cp1y}, ${x} ${y}, ${x} ${y}`;
    }
    tempConnectionLine.setAttribute('d', d);
}

function finishConnection(el, position) {
    if (!isConnecting || !connectionStart) return;

    // Remove temp line
    if (tempConnectionLine) {
        tempConnectionLine.remove();
        tempConnectionLine = null;
    }

    if (connectionStart.element !== el) {
        // Determine connection type based on current tool
        const connType = currentTool === 'causal' ? 'causal' : 'arrow';
        createConnection(
            connectionStart.element.dataset.id,
            connectionStart.position,
            el.dataset.id,
            position,
            { type: connType, style: connectorStyle }
        );
        console.log('Created', connType, connectorStyle, 'connection to', el.dataset.id, position);
    }

    isConnecting = false;
    connectionStart = null;
    canvasContainer.style.cursor = (currentTool === 'connect' || currentTool === 'causal') ? 'crosshair' : 'default';
}

function cancelConnection() {
    if (tempConnectionLine) {
        tempConnectionLine.remove();
        tempConnectionLine = null;
    }
    isConnecting = false;
    connectionStart = null;
    canvasContainer.style.cursor = (currentTool === 'connect' || currentTool === 'causal') ? 'crosshair' : 'default';
}

function createConnection(fromId, fromPos, toId, toPos, options = {}, skipHistory = false) {
    if (!skipHistory) saveState();
    const id = `conn-${connections.length}`;
    connections.push({
        id,
        from: { elementId: fromId, position: fromPos },
        to: { elementId: toId, position: toPos },
        ...options
    });
    renderConnections();
}

function renderConnections() {
    // Clear existing paths and labels
    connectionsSvg.querySelectorAll('path, text').forEach(p => p.remove());

    connections.forEach(conn => {
        const fromEl = document.querySelector(`[data-id="${conn.from.elementId}"]`);
        const toEl = document.querySelector(`[data-id="${conn.to.elementId}"]`);

        if (!fromEl || !toEl) return;

        const fromPoint = getConnectionPoint(fromEl, conn.from.position);
        const toPoint = getConnectionPoint(toEl, conn.to.position);

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

        // Calculate path based on connector style
        const style = conn.style || 'orthogonal';
        let d;
        if (style === 'straight') {
            d = calculateStraightPath(fromPoint, toPoint);
        } else if (style === 'orthogonal') {
            d = calculateOrthogonalPath(fromPoint, toPoint);
        } else {
            d = calculateCurvedPath(fromPoint, toPoint);
        }

        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.dataset.connectionId = conn.id;

        // Style based on connection type
        const isCausal = conn.type === 'causal';
        if (isCausal) {
            path.setAttribute('stroke', '#e89547');
            path.setAttribute('stroke-width', '3');
            path.setAttribute('marker-end', 'url(#arrowhead-causal)');
            path.classList.add('wb-causal-connection');

            // Add IF label near the start
            const ifLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            ifLabel.setAttribute('x', fromPoint.x + fromPoint.dir.x * 20);
            ifLabel.setAttribute('y', fromPoint.y + fromPoint.dir.y * 20);
            ifLabel.setAttribute('text-anchor', 'middle');
            ifLabel.setAttribute('dominant-baseline', 'middle');
            ifLabel.classList.add('wb-connection-label', 'if-label');
            ifLabel.textContent = 'IF';
            connectionsSvg.appendChild(ifLabel);

            // Add THEN label near the end
            const thenLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            thenLabel.setAttribute('x', toPoint.x - toPoint.dir.x * 25);
            thenLabel.setAttribute('y', toPoint.y - toPoint.dir.y * 25);
            thenLabel.setAttribute('text-anchor', 'middle');
            thenLabel.setAttribute('dominant-baseline', 'middle');
            thenLabel.classList.add('wb-connection-label', 'then-label');
            thenLabel.textContent = 'THEN';
            connectionsSvg.appendChild(thenLabel);
        } else {
            path.setAttribute('stroke', '#4a9f6e');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('marker-end', 'url(#arrowhead)');
        }

        const originalStroke = isCausal ? '#e89547' : '#4a9f6e';
        path.addEventListener('click', () => {
            // Select connection for deletion
            path.setAttribute('stroke', '#e85747');
            setTimeout(() => {
                if (confirm('Delete this connection?')) {
                    saveState();
                    connections = connections.filter(c => c.id !== conn.id);
                    renderConnections();
                } else {
                    path.setAttribute('stroke', originalStroke);
                }
            }, 100);
        });

        connectionsSvg.appendChild(path);
    });
}

function getConnectionPoint(el, position) {
    // Get position directly from element's style (canvas coordinates)
    const x = parseFloat(el.style.left) || 0;
    const y = parseFloat(el.style.top) || 0;
    const w = el.offsetWidth;
    const h = el.offsetHeight;

    // Padding to keep arrows outside shape bounds
    const pad = 8;

    // Check if this is a diamond shape (corners extend beyond bounding box)
    const isDiamond = el.classList.contains('diamond');
    // Diamond corners extend ~21% beyond the bounding box (sqrt(2)-1)/2 ≈ 0.207
    const cornerExt = isDiamond ? 0.21 : 0;

    switch (position) {
        case 'top': return { x: x + w/2, y: y - cornerExt * h - pad, dir: { x: 0, y: -1 } };
        case 'bottom': return { x: x + w/2, y: y + h + cornerExt * h + pad, dir: { x: 0, y: 1 } };
        case 'left': return { x: x - cornerExt * w - pad, y: y + h/2, dir: { x: -1, y: 0 } };
        case 'right': return { x: x + w + cornerExt * w + pad, y: y + h/2, dir: { x: 1, y: 0 } };
        default: return { x: x + w/2, y: y + h/2, dir: { x: 0, y: 0 } };
    }
}

// ---------- Straight connector ----------
function calculateStraightPath(from, to) {
    return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
}

// ---------- Orthogonal (right-angle) connector ----------
function calculateOrthogonalPath(from, to) {
    const stub = 20; // minimum distance out from the port before turning

    // Exit points: go out from the port in its direction
    const ax = from.x + from.dir.x * stub;
    const ay = from.y + from.dir.y * stub;
    const bx = to.x + to.dir.x * stub;
    const by = to.y + to.dir.y * stub;

    const fromH = from.dir.x !== 0; // from port is horizontal
    const toH = to.dir.x !== 0;     // to port is horizontal

    let points;

    if (fromH && toH) {
        // Both horizontal — connect with a vertical bridge
        const midX = (ax + bx) / 2;
        points = [
            { x: from.x, y: from.y },
            { x: ax, y: ay },
            { x: midX, y: ay },
            { x: midX, y: by },
            { x: bx, y: by },
            { x: to.x, y: to.y }
        ];
    } else if (!fromH && !toH) {
        // Both vertical — connect with a horizontal bridge
        const midY = (ay + by) / 2;
        points = [
            { x: from.x, y: from.y },
            { x: ax, y: ay },
            { x: ax, y: midY },
            { x: bx, y: midY },
            { x: bx, y: by },
            { x: to.x, y: to.y }
        ];
    } else {
        // One horizontal, one vertical — single elbow
        if (fromH) {
            // from goes horizontal, to goes vertical → meet at (ax, by)
            // But check if the elbow would backtrack; if so, add extra segment
            const elbowX = bx;
            const elbowY = ay;
            points = [
                { x: from.x, y: from.y },
                { x: ax, y: ay },
                { x: elbowX, y: elbowY },
                { x: bx, y: by },
                { x: to.x, y: to.y }
            ];
        } else {
            // from goes vertical, to goes horizontal → meet at (bx, ay)
            const elbowX = ax;
            const elbowY = by;
            points = [
                { x: from.x, y: from.y },
                { x: ax, y: ay },
                { x: elbowX, y: elbowY },
                { x: bx, y: by },
                { x: to.x, y: to.y }
            ];
        }
    }

    // Remove duplicate consecutive points
    const clean = [points[0]];
    for (let i = 1; i < points.length; i++) {
        const prev = clean[clean.length - 1];
        if (Math.abs(points[i].x - prev.x) > 0.5 || Math.abs(points[i].y - prev.y) > 0.5) {
            clean.push(points[i]);
        }
    }

    return 'M ' + clean.map(p => `${p.x} ${p.y}`).join(' L ');
}

// ---------- Curved (bezier) connector ----------
function calculateCurvedPath(from, to) {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 20) {
        return `M ${from.x} ${from.y} L ${to.x} ${to.y}`;
    }

    // Control point distance: proportional to distance, clamped
    const cpDist = Math.min(120, Math.max(30, dist * 0.4));

    // cp1: go out from source in its port direction
    const cp1x = from.x + from.dir.x * cpDist;
    const cp1y = from.y + from.dir.y * cpDist;

    // cp2: approach target from its port direction (to.dir points outward,
    // so adding it pushes the control point AWAY from the target, which
    // makes the curve arrive FROM that direction — exactly what we want)
    const cp2x = to.x + to.dir.x * cpDist;
    const cp2y = to.y + to.dir.y * cpDist;

    return `M ${from.x} ${from.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${to.x} ${to.y}`;
}

// ============================================================================
// Canvas Events
// ============================================================================

canvasContainer.addEventListener('mousedown', (e) => {
    if (e.target === canvasContainer || e.target === canvas) {
        deselectAll();

        if (currentTool === 'pan' || e.button === 1) {
            isPanning = true;
            canvasContainer.style.cursor = 'grabbing';
        } else if (currentTool === 'postit') {
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left - panX) / zoom;
            const y = (e.clientY - rect.top - panY) / zoom;
            const el = createElement('postit', x, y);
            selectElement(el);
        } else if (currentTool === 'text') {
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left - panX) / zoom;
            const y = (e.clientY - rect.top - panY) / zoom;
            const el = createElement('text', x, y);
            selectElement(el);
        } else if (currentTool === 'group') {
            const rect = canvasContainer.getBoundingClientRect();
            const x = (e.clientX - rect.left - panX) / zoom;
            const y = (e.clientY - rect.top - panY) / zoom;
            const el = createElement('group', x, y);
            selectElement(el);
        }
    }
});

canvasContainer.addEventListener('mousemove', (e) => {
    if (isPanning) {
        panX += e.movementX;
        panY += e.movementY;
        updateCanvasTransform();
    } else if (isDragging && selectedElement) {
        if (!didDrag) {
            saveState(); // Save state on first move
            didDrag = true;
        }
        const rect = canvasContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left - panX) / zoom - dragOffset.x;
        const y = (e.clientY - rect.top - panY) / zoom - dragOffset.y;

        selectedElement.style.left = `${x}px`;
        selectedElement.style.top = `${y}px`;

        updateElementData(selectedElement.dataset.id, { x, y });
        renderConnections();
    } else if (isConnecting) {
        updateTempConnection(e);
    }
});

canvasContainer.addEventListener('mouseup', (e) => {
    if (isPanning) {
        isPanning = false;
        canvasContainer.style.cursor = currentTool === 'pan' ? 'grab' : 'default';
    }
    if (isDragging) {
        isDragging = false;
        if (selectedElement) {
            selectedElement.style.cursor = 'move';
        }
    }
    if (isConnecting) {
        // Check if mouse is over a connection point
        const target = e.target;
        if (target.classList.contains('wb-connection-point')) {
            const el = target.closest('.wb-element');
            const pos = ['top', 'bottom', 'left', 'right'].find(p => target.classList.contains(p));
            finishConnection(el, pos);
        } else {
            // Cancel the connection if not dropped on a connection point
            cancelConnection();
        }
    }
});

canvasContainer.addEventListener('wheel', (e) => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? -0.1 : 0.1;
    zoom = Math.max(0.25, Math.min(3, zoom + delta));
    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;
});

// ============================================================================
// Zoom Controls
// ============================================================================

function zoomIn() {
    zoom = Math.min(3, zoom + 0.25);
    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;
}

function zoomOut() {
    zoom = Math.max(0.25, zoom - 0.25);
    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;
}

function zoomReset() {
    zoom = 1;
    panX = 0;
    panY = 0;
    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = '100%';
}

function updateCanvasTransform() {
    canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
    // SVG is now inside canvas, so it transforms automatically
}

// ============================================================================
// Context Menu
// ============================================================================

function showContextMenu(x, y) {
    contextMenu.style.left = `${x}px`;
    contextMenu.style.top = `${y}px`;
    contextMenu.classList.add('active');
}

function hideContextMenu() {
    contextMenu.classList.remove('active');
}

document.addEventListener('click', (e) => {
    if (!contextMenu.contains(e.target)) {
        hideContextMenu();
    }
});

function duplicateSelected() {
    if (!selectedElement) return;
    hideContextMenu();

    const data = elements.find(el => el.id === selectedElement.dataset.id);
    if (!data) return;

    const newEl = createElement(data.type, data.x + 20, data.y + 20, { ...data });
    selectElement(newEl);
}

function bringToFront() {
    if (!selectedElement) return;
    hideContextMenu();
    canvas.appendChild(selectedElement);
}

function sendToBack() {
    if (!selectedElement) return;
    hideContextMenu();
    canvas.insertBefore(selectedElement, canvas.firstChild);
}

function deleteSelected() {
    if (!selectedElement) return;
    hideContextMenu();
    saveState();

    const id = selectedElement.dataset.id;

    // Remove connections to/from this element
    connections = connections.filter(c =>
        c.from.elementId !== id && c.to.elementId !== id
    );
    renderConnections();

    // Remove element data
    elements = elements.filter(el => el.id !== id);

    // Remove DOM element
    selectedElement.remove();
    selectedElement = null;

    document.getElementById('properties-panel').classList.remove('active');
}

// ============================================================================
// Properties Panel
// ============================================================================

function showProperties(el) {
    const panel = document.getElementById('properties-panel');
    const content = document.getElementById('properties-content');
    const data = elements.find(e => e.id === el.dataset.id);

    if (!data) return;

    let html = '';

    if (data.type === 'postit' || data.type === 'text') {
        html = `
            <div class="wb-prop-group">
                <div class="wb-prop-label">Content</div>
                <textarea class="wb-prop-input" style="height:80px;resize:vertical;"
                    onchange="updateElementContent('${data.id}', this.value)">${el.textContent}</textarea>
            </div>
        `;
    }

    if (data.type === 'group') {
        html = `
            <div class="wb-prop-group">
                <div class="wb-prop-label">Title</div>
                <input class="wb-prop-input" type="text" value="${data.title || ''}"
                    onchange="updateGroupTitle('${data.id}', this.value)">
            </div>
            <div class="wb-prop-group">
                <div class="wb-prop-label">Width</div>
                <input class="wb-prop-input" type="number" value="${data.width || 250}"
                    onchange="updateGroupSize('${data.id}', this.value, null)">
            </div>
            <div class="wb-prop-group">
                <div class="wb-prop-label">Height</div>
                <input class="wb-prop-input" type="number" value="${data.height || 200}"
                    onchange="updateGroupSize('${data.id}', null, this.value)">
            </div>
        `;
    }

    html += `
        <div class="wb-prop-group">
            <div class="wb-prop-label">Position</div>
            <div style="display:flex;gap:8px;">
                <input class="wb-prop-input" type="number" value="${Math.round(data.x)}" placeholder="X"
                    onchange="updateElementPosition('${data.id}', this.value, null)" style="flex:1;">
                <input class="wb-prop-input" type="number" value="${Math.round(data.y)}" placeholder="Y"
                    onchange="updateElementPosition('${data.id}', null, this.value)" style="flex:1;">
            </div>
        </div>
    `;

    content.innerHTML = html;
    panel.classList.add('active');
}

function updateElementData(id, updates) {
    const idx = elements.findIndex(el => el.id === id);
    if (idx >= 0) {
        elements[idx] = { ...elements[idx], ...updates };
    }
}

function updateElementContent(id, text) {
    const el = document.querySelector(`[data-id="${id}"]`);
    if (el) {
        el.textContent = text;
        updateElementData(id, { text });
    }
}

function updateElementPosition(id, x, y) {
    const el = document.querySelector(`[data-id="${id}"]`);
    if (el) {
        if (x !== null) el.style.left = `${x}px`;
        if (y !== null) el.style.top = `${y}px`;
        updateElementData(id, {
            x: x !== null ? parseFloat(x) : elements.find(e => e.id === id)?.x,
            y: y !== null ? parseFloat(y) : elements.find(e => e.id === id)?.y
        });
        renderConnections();
    }
}

function updateGroupTitle(id, title) {
    const el = document.querySelector(`[data-id="${id}"]`);
    if (el) {
        el.querySelector('.wb-group-header').textContent = title;
        updateElementData(id, { title });
    }
}

function updateGroupSize(id, width, height) {
    const el = document.querySelector(`[data-id="${id}"]`);
    if (el) {
        if (width !== null) el.style.width = `${width}px`;
        if (height !== null) el.style.height = `${height}px`;
        updateElementData(id, {
            width: width !== null ? parseFloat(width) : elements.find(e => e.id === id)?.width,
            height: height !== null ? parseFloat(height) : elements.find(e => e.id === id)?.height
        });
    }
}

// ============================================================================
// Templates
// ============================================================================

function clearCanvas(resetHistory = false) {
    // Remove elements but preserve the SVG
    canvas.querySelectorAll('.wb-element').forEach(el => el.remove());
    connectionsSvg.querySelectorAll('path').forEach(p => p.remove());
    elements = [];
    connections = [];
    elementIdCounter = 0;
    selectedElement = null;

    if (resetHistory) {
        history = [];
        historyIndex = -1;
    }
}

function loadTemplate(template) {
    clearCanvas(true); // Reset history for templates

    switch (template) {
        case 'affinity':
            // Create groups
            createElement('group', 50, 50, { title: 'Theme 1', width: 280, height: 300 });
            createElement('group', 360, 50, { title: 'Theme 2', width: 280, height: 300 });
            createElement('group', 670, 50, { title: 'Theme 3', width: 280, height: 300 });

            // Add sample post-its
            createElement('postit', 70, 120, { color: 'yellow', text: 'Idea 1' });
            createElement('postit', 70, 240, { color: 'yellow', text: 'Idea 2' });
            createElement('postit', 380, 120, { color: 'green', text: 'Idea 3' });
            createElement('postit', 690, 120, { color: 'pink', text: 'Idea 4' });
            break;

        case 'interrelationship':
            // Create nodes in a circle
            const centerX = 400, centerY = 250, radius = 180;
            const nodes = ['Factor A', 'Factor B', 'Factor C', 'Factor D', 'Factor E'];
            nodes.forEach((name, i) => {
                const angle = (i / nodes.length) * 2 * Math.PI - Math.PI/2;
                const x = centerX + radius * Math.cos(angle) - 60;
                const y = centerY + radius * Math.sin(angle) - 30;
                createElement('rectangle', x, y, { text: name });
            });
            break;

        case 'process':
            createElement('oval', 50, 150, { text: 'Start' });
            createElement('rectangle', 200, 140, { text: 'Step 1' });
            createElement('diamond', 370, 130, { text: 'Decision?' });
            createElement('rectangle', 500, 140, { text: 'Step 2' });
            createElement('oval', 670, 150, { text: 'End' });

            // Add connections
            setTimeout(() => {
                createConnection('el-1', 'right', 'el-2', 'left');
                createConnection('el-2', 'right', 'el-3', 'left');
                createConnection('el-3', 'right', 'el-4', 'left');
                createConnection('el-4', 'right', 'el-5', 'left');
            }, 100);
            break;

        case 'vsm':
            // Supplier
            createElement('rectangle', 50, 100, { text: 'Supplier' });

            // Process boxes
            createElement('rectangle', 200, 100, { text: 'Process 1' });
            createElement('rectangle', 380, 100, { text: 'Process 2' });
            createElement('rectangle', 560, 100, { text: 'Process 3' });

            // Customer
            createElement('rectangle', 720, 100, { text: 'Customer' });

            // Timeline
            createElement('text', 50, 280, { text: 'Lead Time: ___' });
            break;

        case 'fishbone':
            createFishbone(50, 100, 'Hypothesis / Effect');
            break;
    }

    // Save initial state after template load
    setTimeout(() => saveState(), 100);
}

// ============================================================================
// Drag and Drop from Sidebar
// ============================================================================

document.querySelectorAll('.wb-shape-item[draggable="true"]').forEach(item => {
    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('shape', item.dataset.shape);
    });
});

canvasContainer.addEventListener('dragover', (e) => {
    e.preventDefault();
});

canvasContainer.addEventListener('drop', (e) => {
    e.preventDefault();
    const shape = e.dataTransfer.getData('shape');
    if (shape) {
        const rect = canvasContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left - panX) / zoom;
        const y = (e.clientY - rect.top - panY) / zoom;
        const el = createElement(shape, x, y);
        selectElement(el);
    }
});

// ============================================================================
// Keyboard Shortcuts
// ============================================================================

document.addEventListener('keydown', (e) => {
    // Don't handle if typing in an editable element
    if (e.target.contentEditable === 'true' || e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }

    switch (e.key.toLowerCase()) {
        case 'v':
            document.querySelector('[data-tool="select"]').click();
            break;
        case 'p':
            document.querySelector('[data-tool="postit"]').click();
            break;
        case 'c':
            document.querySelector('[data-tool="connect"]').click();
            break;
        case 'i':
            document.querySelector('[data-tool="causal"]').click();
            break;
        case 't':
            document.querySelector('[data-tool="text"]').click();
            break;
        case 'g':
            document.querySelector('[data-tool="group"]').click();
            break;
        case 'delete':
        case 'backspace':
            if (selectedElement) {
                deleteSelected();
            }
            break;
        case '=':
        case '+':
            zoomIn();
            break;
        case '-':
            zoomOut();
            break;
        case '0':
            zoomReset();
            break;
        case 's':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                saveBoard();
            }
            break;
        case 'z':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            }
            break;
        case 'y':
            if (e.ctrlKey || e.metaKey) {
                e.preventDefault();
                redo();
            }
            break;
        case 'escape':
            if (isConnecting) {
                cancelConnection();
            } else {
                deselectAll();
                currentTool = 'select';
                document.querySelector('[data-tool="select"]').click();
            }
            break;
    }

    // Space for panning
    if (e.code === 'Space' && !isPanning) {
        e.preventDefault();
        canvasContainer.style.cursor = 'grab';
    }
});

document.addEventListener('keyup', (e) => {
    if (e.code === 'Space') {
        canvasContainer.style.cursor = currentTool === 'pan' ? 'grab' : 'default';
    }
});

// ============================================================================
// Save/Load
// ============================================================================

function saveBoard() {
    const boardData = {
        elements,
        connections,
        zoom,
        panX,
        panY,
        timestamp: new Date().toISOString()
    };

    const name = prompt('Board name:', 'Untitled Board');
    if (!name) return;

    // Save to localStorage for now
    const boards = JSON.parse(localStorage.getItem('wb-boards') || '{}');
    boards[name] = boardData;
    localStorage.setItem('wb-boards', JSON.stringify(boards));

    loadBoardsList();
    alert('Board saved!');
}

function loadBoard(name) {
    const boards = JSON.parse(localStorage.getItem('wb-boards') || '{}');
    const data = boards[name];
    if (!data) return;

    clearCanvas(true); // Reset history when loading board
    connections = data.connections || [];
    zoom = data.zoom || 1;
    panX = data.panX || 0;
    panY = data.panY || 0;
    elementIdCounter = 0;

    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;

    // Recreate elements
    data.elements.forEach(el => {
        createElement(el.type, el.x, el.y, el);
        elementIdCounter = Math.max(elementIdCounter, parseInt(el.id.split('-')[1]) || 0);
    });

    // Recreate connections
    setTimeout(() => renderConnections(), 100);
}

function loadBoardsList() {
    const boards = JSON.parse(localStorage.getItem('wb-boards') || '{}');
    const list = document.getElementById('boards-list');

    if (Object.keys(boards).length === 0) {
        list.innerHTML = '<div style="color:var(--wb-text-dim);font-size:11px;text-align:center;padding:20px;">No saved boards yet</div>';
        return;
    }

    list.innerHTML = Object.keys(boards).map(name => `
        <div class="wb-template-item" style="position:relative;">
            <div class="icon" onclick="loadBoard('${name}')" style="cursor:pointer;">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="3" width="18" height="18" rx="2"/>
                </svg>
            </div>
            <div class="info" onclick="loadBoard('${name}')" style="cursor:pointer;">
                <div class="name">${name}</div>
                <div class="desc">${new Date(boards[name].timestamp).toLocaleDateString()}</div>
            </div>
            <button onclick="deleteBoard('${name}')" title="Delete board" style="
                position:absolute;right:8px;top:50%;transform:translateY(-50%);
                background:transparent;border:none;color:#9aaa9a;cursor:pointer;
                padding:4px;opacity:0.5;transition:opacity 0.15s;
            " onmouseover="this.style.opacity='1';this.style.color='#e85747'" onmouseout="this.style.opacity='0.5';this.style.color='#9aaa9a'">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                </svg>
            </button>
        </div>
    `).join('');
}

function deleteBoard(name) {
    if (!confirm(`Delete board "${name}"?`)) return;

    const boards = JSON.parse(localStorage.getItem('wb-boards') || '{}');
    delete boards[name];
    localStorage.setItem('wb-boards', JSON.stringify(boards));
    loadBoardsList();
}

function newBoard() {
    if (elements.length > 0 && !confirm('Clear current board?')) return;

    clearCanvas();
    zoom = 1;
    panX = 0;
    panY = 0;
    updateCanvasTransform();
    document.getElementById('zoom-display').textContent = '100%';
}

function exportBoard(format) {
    if (format === 'png') {
        // Create a canvas and draw all elements
        const exportCanvas = document.createElement('canvas');
        const ctx = exportCanvas.getContext('2d');

        // Calculate bounds of all elements
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        elements.forEach(el => {
            minX = Math.min(minX, el.x);
            minY = Math.min(minY, el.y);
            const domEl = document.querySelector(`[data-id="${el.id}"]`);
            if (domEl) {
                maxX = Math.max(maxX, el.x + domEl.offsetWidth);
                maxY = Math.max(maxY, el.y + domEl.offsetHeight);
            }
        });

        if (elements.length === 0) {
            alert('Nothing to export. Add some elements first.');
            return;
        }

        const padding = 40;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;

        exportCanvas.width = width;
        exportCanvas.height = height;

        // Background
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, width, height);

        // Draw grid
        ctx.strokeStyle = '#252525';
        ctx.lineWidth = 1;
        for (let x = 0; x < width; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        for (let y = 0; y < height; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }

        // Draw connections
        ctx.strokeStyle = '#4a9f6e';
        ctx.lineWidth = 2;
        connections.forEach(conn => {
            const fromEl = document.querySelector(`[data-id="${conn.from.elementId}"]`);
            const toEl = document.querySelector(`[data-id="${conn.to.elementId}"]`);
            if (!fromEl || !toEl) return;

            const from = getConnectionPoint(fromEl, conn.from.position);
            const to = getConnectionPoint(toEl, conn.to.position);

            ctx.beginPath();
            ctx.moveTo(from.x - minX + padding, from.y - minY + padding);
            ctx.lineTo(to.x - minX + padding, to.y - minY + padding);
            ctx.stroke();

            // Arrow
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            const headLen = 10;
            ctx.beginPath();
            ctx.moveTo(to.x - minX + padding, to.y - minY + padding);
            ctx.lineTo(
                to.x - minX + padding - headLen * Math.cos(angle - Math.PI/6),
                to.y - minY + padding - headLen * Math.sin(angle - Math.PI/6)
            );
            ctx.moveTo(to.x - minX + padding, to.y - minY + padding);
            ctx.lineTo(
                to.x - minX + padding - headLen * Math.cos(angle + Math.PI/6),
                to.y - minY + padding - headLen * Math.sin(angle + Math.PI/6)
            );
            ctx.stroke();
        });

        // Draw elements
        elements.forEach(el => {
            const domEl = document.querySelector(`[data-id="${el.id}"]`);
            if (!domEl) return;

            const x = el.x - minX + padding;
            const y = el.y - minY + padding;
            const w = domEl.offsetWidth;
            const h = domEl.offsetHeight;

            if (el.type === 'postit') {
                const colors = {
                    yellow: '#feff9c', green: '#7afcff', pink: '#ff7eb9',
                    orange: '#ff9f43', blue: '#74b9ff', purple: '#a29bfe'
                };
                ctx.fillStyle = colors[el.color] || '#feff9c';
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                ctx.fillRect(x, y, w, h);
                ctx.shadowColor = 'transparent';

                ctx.fillStyle = '#333';
                ctx.font = '13px Inter, sans-serif';
                wrapText(ctx, domEl.textContent, x + 12, y + 20, w - 24, 18);
            } else if (el.type === 'group') {
                ctx.strokeStyle = '#4a9f6e';
                ctx.setLineDash([8, 4]);
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
                ctx.setLineDash([]);

                ctx.fillStyle = '#4a9f6e';
                ctx.fillRect(x + 8, y + 8, w - 16, 30);
                ctx.fillStyle = 'white';
                ctx.font = '600 14px Inter, sans-serif';
                ctx.fillText(el.title || 'Group', x + 16, y + 28);
            } else if (el.type === 'text') {
                ctx.fillStyle = '#e8efe8';
                ctx.font = '14px Inter, sans-serif';
                ctx.fillText(domEl.textContent, x, y + 14);
            } else if (el.type === 'fishbone') {
                // Draw fishbone diagram
                const spineY = y + h/2;

                // Main spine
                ctx.strokeStyle = '#4a9f6e';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(x + 50, spineY);
                ctx.lineTo(x + w - 120, spineY);
                ctx.stroke();

                // Effect box
                ctx.fillStyle = '#4a9f6e';
                ctx.fillRect(x + w - 120, spineY - 30, 120, 60);
                ctx.fillStyle = 'white';
                ctx.font = '600 14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(el.effect || 'Effect', x + w - 60, spineY + 5);
                ctx.textAlign = 'left';

                // Draw categories and causes
                if (el.categories) {
                    const boneSpacing = (w - 250) / 3;
                    el.categories.forEach((cat, i) => {
                        const isTop = i < 3;
                        const boneX = x + 80 + (i % 3) * boneSpacing;

                        // Bone line
                        ctx.strokeStyle = '#4a9f6e';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(boneX, spineY);
                        const endY = isTop ? spineY - 100 : spineY + 100;
                        ctx.lineTo(boneX + 30, endY);
                        ctx.stroke();

                        // Category label
                        ctx.fillStyle = '#4a9f6e';
                        ctx.font = '600 12px Inter, sans-serif';
                        const catY = isTop ? spineY - 115 : spineY + 125;
                        ctx.fillText(cat.name, boneX, catY);

                        // Causes
                        ctx.font = '11px Inter, sans-serif';
                        ctx.fillStyle = '#e8efe8';
                        cat.causes.forEach((cause, j) => {
                            const causeY = isTop
                                ? catY - 18 - j * 16
                                : catY + 18 + j * 16;
                            ctx.fillText('• ' + cause, boneX, causeY);
                        });
                    });
                }
            } else {
                // Process shapes
                ctx.fillStyle = '#121a12';
                ctx.strokeStyle = '#4a9f6e';
                ctx.lineWidth = 2;

                if (el.type === 'diamond') {
                    ctx.beginPath();
                    ctx.moveTo(x + w/2, y);
                    ctx.lineTo(x + w, y + h/2);
                    ctx.lineTo(x + w/2, y + h);
                    ctx.lineTo(x, y + h/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (el.type === 'oval') {
                    ctx.beginPath();
                    ctx.ellipse(x + w/2, y + h/2, w/2, h/2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeRect(x, y, w, h);
                }

                ctx.fillStyle = '#e8efe8';
                ctx.font = '12px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(el.text || '', x + w/2, y + h/2 + 4);
                ctx.textAlign = 'left';
            }
        });

        // Download
        const link = document.createElement('a');
        link.download = 'whiteboard.png';
        link.href = exportCanvas.toDataURL('image/png');
        link.click();
    }
}

function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';

    for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) {
            ctx.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
        } else {
            line = testLine;
        }
    }
    ctx.fillText(line, x, y);
}

// ============================================================================
// Fishbone / Ishikawa Diagram
// ============================================================================

function createFishbone(x, y, effect) {
    const id = `fishbone-${++elementIdCounter}`;

    // Standard 6M categories
    const categories = [
        { name: 'People', causes: ['Training', 'Skills'] },
        { name: 'Process', causes: ['Procedure', 'Method'] },
        { name: 'Equipment', causes: ['Tools', 'Machines'] },
        { name: 'Materials', causes: ['Quality', 'Supply'] },
        { name: 'Environment', causes: ['Conditions', 'Layout'] },
        { name: 'Measurement', causes: ['Accuracy', 'Calibration'] }
    ];

    // Store fishbone data
    const fishboneData = {
        id,
        type: 'fishbone',
        x,
        y,
        effect,
        categories: categories.map(c => ({
            name: c.name,
            causes: [...c.causes]
        }))
    };
    elements.push(fishboneData);

    // Create DOM element
    const el = document.createElement('div');
    el.className = 'wb-element wb-fishbone';
    el.dataset.id = id;
    el.dataset.type = 'fishbone';
    el.style.left = `${x}px`;
    el.style.top = `${y}px`;

    renderFishbone(el, fishboneData);

    // Make draggable
    el.addEventListener('mousedown', (e) => {
        if (e.target.contentEditable === 'true' || e.target.classList.contains('wb-fishbone-add')) return;
        onElementMouseDown(e, el);
    });

    canvas.appendChild(el);
    return el;
}

function renderFishbone(el, data) {
    const spineLength = 700;
    const boneSpacing = spineLength / 4;

    let html = `
        <div class="wb-fishbone-spine"></div>
        <div class="wb-fishbone-head" contenteditable="true"
             onblur="updateFishboneEffect('${data.id}', this.textContent)">${data.effect}</div>
    `;

    data.categories.forEach((cat, i) => {
        const isTop = i < 3;
        const xPos = 80 + (i % 3) * boneSpacing;
        const boneHeight = 120;

        // Bone line
        html += `
            <div class="wb-fishbone-bone ${isTop ? 'top' : 'bottom'}"
                 style="left: ${xPos}px; ${isTop ? 'bottom' : 'top'}: 50%; height: ${boneHeight}px;">
            </div>
        `;

        // Category label position
        const catY = isTop ? -boneHeight - 30 : boneHeight + 10;
        const catX = xPos + (isTop ? -50 : -50);

        html += `
            <div class="wb-fishbone-category"
                 style="left: ${xPos - 40}px; ${isTop ? 'top: 60px' : 'bottom: 60px'};"
                 contenteditable="true"
                 onblur="updateFishboneCategory('${data.id}', ${i}, this.textContent)">${cat.name}</div>
        `;

        // Causes container
        html += `
            <div class="wb-fishbone-causes ${isTop ? 'top' : 'bottom'}"
                 style="left: ${xPos - 30}px; ${isTop ? 'top: 100px' : 'bottom: 100px'};"
                 data-category="${i}">
        `;

        cat.causes.forEach((cause, j) => {
            html += `
                <div class="wb-fishbone-cause" contenteditable="true"
                     onblur="updateFishboneCause('${data.id}', ${i}, ${j}, this.textContent)">${cause}</div>
            `;
        });

        html += `
                <button class="wb-fishbone-add" onclick="addFishboneCause('${data.id}', ${i})">+ Add cause</button>
            </div>
        `;
    });

    el.innerHTML = html;
}

function updateFishboneEffect(id, text) {
    const data = elements.find(e => e.id === id);
    if (data) {
        saveState();
        data.effect = text;
    }
}

function updateFishboneCategory(id, catIndex, text) {
    const data = elements.find(e => e.id === id);
    if (data && data.categories[catIndex]) {
        saveState();
        data.categories[catIndex].name = text;
    }
}

function updateFishboneCause(id, catIndex, causeIndex, text) {
    const data = elements.find(e => e.id === id);
    if (data && data.categories[catIndex]) {
        saveState();
        if (text.trim() === '') {
            // Remove empty causes
            data.categories[catIndex].causes.splice(causeIndex, 1);
            const el = document.querySelector(`[data-id="${id}"]`);
            if (el) renderFishbone(el, data);
        } else {
            data.categories[catIndex].causes[causeIndex] = text;
        }
    }
}

function addFishboneCause(id, catIndex) {
    const data = elements.find(e => e.id === id);
    if (data && data.categories[catIndex]) {
        saveState();
        data.categories[catIndex].causes.push('New cause');
        const el = document.querySelector(`[data-id="${id}"]`);
        if (el) {
            renderFishbone(el, data);
            // Focus the new cause
            const causes = el.querySelectorAll(`[data-category="${catIndex}"] .wb-fishbone-cause`);
            const lastCause = causes[causes.length - 1];
            if (lastCause) {
                lastCause.focus();
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(lastCause);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }
    }
}

// ============================================================================
// Affinity to Interrelationship Conversion
// ============================================================================

function convertAffinityToIR() {
    // Find all group elements and extract their titles
    const groups = elements.filter(el => el.type === 'group');

    if (groups.length === 0) {
        alert('No groups found. Create an Affinity Diagram with groups first.');
        return;
    }

    if (groups.length < 2) {
        alert('Need at least 2 groups to create an Interrelationship Diagram.');
        return;
    }

    // Extract titles from groups
    const factors = groups.map(g => {
        const domEl = document.querySelector(`[data-id="${g.id}"]`);
        const header = domEl?.querySelector('.wb-group-header');
        return header?.textContent || g.title || 'Factor';
    });

    if (!confirm(`Convert ${factors.length} groups to Interrelationship Diagram?\n\nFactors: ${factors.join(', ')}`)) {
        return;
    }

    // Clear canvas
    clearCanvas();

    // Calculate layout - arrange in a circle
    const centerX = 450;
    const centerY = 300;
    const radius = Math.min(250, 80 + factors.length * 30);

    factors.forEach((name, i) => {
        const angle = (i / factors.length) * 2 * Math.PI - Math.PI/2;
        const x = centerX + radius * Math.cos(angle) - 60;
        const y = centerY + radius * Math.sin(angle) - 30;
        createElement('rectangle', x, y, { text: name });
    });

    // Add instruction text
    createElement('text', centerX - 100, centerY - 10, {
        text: 'Draw arrows to show cause → effect'
    });

    // Switch to connect tool
    document.querySelector('[data-tool="connect"]').click();
}

function analyzeIR() {
    // Count incoming and outgoing connections for each element
    const shapes = elements.filter(el =>
        ['rectangle', 'diamond', 'oval', 'parallelogram', 'document', 'cylinder'].includes(el.type)
    );

    if (shapes.length === 0) {
        alert('No shapes found to analyze. Create an Interrelationship Diagram first.');
        return;
    }

    if (connections.length === 0) {
        alert('No connections found. Draw arrows between factors to show cause-effect relationships.');
        return;
    }

    // Count arrows for each element
    const analysis = shapes.map(shape => {
        const outgoing = connections.filter(c => c.from.elementId === shape.id).length;
        const incoming = connections.filter(c => c.to.elementId === shape.id).length;
        const domEl = document.querySelector(`[data-id="${shape.id}"]`);
        const text = domEl?.querySelector('span')?.textContent || shape.text || 'Unknown';

        return {
            id: shape.id,
            text,
            outgoing,
            incoming,
            net: outgoing - incoming
        };
    });

    // Sort by net (drivers first, outcomes last)
    analysis.sort((a, b) => b.net - a.net);

    // Build results message
    let msg = 'INTERRELATIONSHIP ANALYSIS\n';
    msg += '═'.repeat(40) + '\n\n';
    msg += 'Factor'.padEnd(20) + 'Out  In   Net\n';
    msg += '─'.repeat(40) + '\n';

    analysis.forEach(item => {
        const label = item.text.substring(0, 18).padEnd(20);
        const out = String(item.outgoing).padStart(3);
        const inc = String(item.incoming).padStart(4);
        const net = (item.net >= 0 ? '+' : '') + item.net;
        msg += `${label}${out} ${inc}   ${net}\n`;
    });

    msg += '─'.repeat(40) + '\n\n';

    // Identify drivers and outcomes
    const drivers = analysis.filter(a => a.net > 0);
    const outcomes = analysis.filter(a => a.net < 0);
    const neutral = analysis.filter(a => a.net === 0);

    if (drivers.length > 0) {
        msg += '🔴 DRIVERS (more outgoing):\n';
        drivers.forEach(d => msg += `   • ${d.text}\n`);
        msg += '\n';
    }

    if (outcomes.length > 0) {
        msg += '🔵 OUTCOMES (more incoming):\n';
        outcomes.forEach(d => msg += `   • ${d.text}\n`);
        msg += '\n';
    }

    if (neutral.length > 0) {
        msg += '⚪ NEUTRAL (equal in/out):\n';
        neutral.forEach(d => msg += `   • ${d.text}\n`);
    }

    msg += '\n💡 Focus improvement efforts on DRIVERS\n   for maximum downstream impact.';

    alert(msg);

    // Also add visual indicators to the diagram
    analysis.forEach(item => {
        const domEl = document.querySelector(`[data-id="${item.id}"]`);
        if (!domEl) return;

        // Remove existing badges
        domEl.querySelectorAll('.ir-badge').forEach(b => b.remove());

        // Add badge
        const badge = document.createElement('div');
        badge.className = 'ir-badge';
        badge.style.cssText = `
            position: absolute;
            top: -12px;
            right: -12px;
            min-width: 24px;
            height: 24px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 6px;
            z-index: 10;
        `;

        if (item.net > 0) {
            badge.style.background = '#e85747';
            badge.style.color = 'white';
            badge.textContent = `+${item.net}`;
            badge.title = 'Driver: ' + item.outgoing + ' out, ' + item.incoming + ' in';
        } else if (item.net < 0) {
            badge.style.background = '#47a5e8';
            badge.style.color = 'white';
            badge.textContent = item.net;
            badge.title = 'Outcome: ' + item.outgoing + ' out, ' + item.incoming + ' in';
        } else {
            badge.style.background = '#9aaa9a';
            badge.style.color = '#0a0f0a';
            badge.textContent = '0';
            badge.title = 'Neutral: ' + item.outgoing + ' out, ' + item.incoming + ' in';
        }

        domEl.appendChild(badge);
    });
}

// ============================================================================
// JSON Export/Import
// ============================================================================

function exportBoardJSON() {
    const boardData = {
        elements,
        connections,
        zoom,
        panX,
        panY,
        timestamp: new Date().toISOString(),
        version: '1.0'
    };

    const json = JSON.stringify(boardData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const link = document.createElement('a');
    link.download = `whiteboard-${Date.now()}.json`;
    link.href = URL.createObjectURL(blob);
    link.click();
    URL.revokeObjectURL(link.href);
}

// ============================================================================
// Causal Relationship Export (If-Then → Hypotheses)
// ============================================================================

function getCausalRelationships() {
    // Find all causal connections
    const causalConns = connections.filter(c => c.type === 'causal');

    // Build hypothesis candidates
    return causalConns.map(conn => {
        const fromEl = elements.find(e => e.id === conn.from.elementId);
        const toEl = elements.find(e => e.id === conn.to.elementId);

        if (!fromEl || !toEl) return null;

        const condition = fromEl.text || fromEl.title || fromEl.effect || 'Unknown condition';
        const effect = toEl.text || toEl.title || toEl.effect || 'Unknown effect';

        // Check if connected through AND/OR gates
        const isGate = fromEl.type === 'gate-and' || fromEl.type === 'gate-or';

        return {
            id: conn.id,
            statement: `If ${condition}, then ${effect}`,
            condition,
            effect,
            conditionElementId: fromEl.id,
            effectElementId: toEl.id,
            hasGate: isGate,
            gateType: isGate ? fromEl.gateType : null
        };
    }).filter(Boolean);
}

async function exportCausalAsHypotheses() {
    const causalRels = getCausalRelationships();

    if (causalRels.length === 0) {
        alert('No if-then relationships found. Use the If-Then tool (I) to create causal connections.');
        return;
    }

    // Check if board is collaborative (has room code)
    if (!roomCode) {
        // Local-only mode - just show the data
        const summary = causalRels.map((rel, i) => `${i + 1}. ${rel.statement}`).join('\n');
        alert(`Found ${causalRels.length} hypothesis candidate(s):\n\n${summary}\n\n(Save board to a project to export to hypotheses)`);
        console.log('Causal relationships (local):', causalRels);
        return causalRels;
    }

    // Format for API
    const hypotheses = causalRels.map(rel => ({
        statement: rel.statement,
        condition: rel.condition,
        effect: rel.effect,
        prior_probability: 0.5,
    }));

    // Show confirmation
    const summary = hypotheses.map((h, i) => `${i + 1}. ${h.statement}`).join('\n');
    if (!confirm(`Export ${hypotheses.length} hypothesis candidate(s) to project?\n\n${summary}`)) {
        return;
    }

    try {
        const response = await fetch(`/api/whiteboard/boards/${roomCode}/export-hypotheses/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ causal_relationships: hypotheses })
        });

        const data = await response.json();

        if (!response.ok) {
            alert(`Error: ${data.error || 'Failed to export hypotheses'}`);
            return;
        }

        // Show success
        let message = `Exported to project "${data.project_title}":\n`;
        message += `- ${data.created_count} new hypothesis(es) created\n`;
        if (data.existing_count > 0) {
            message += `- ${data.existing_count} already existed (skipped)`;
        }
        alert(message);

        console.log('Export result:', data);
        return data;

    } catch (err) {
        console.error('Export failed:', err);
        alert('Failed to export hypotheses. Check console for details.');
    }
}

function importBoardJSON(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);

            if (!data.elements || !Array.isArray(data.elements)) {
                alert('Invalid whiteboard file format.');
                return;
            }

            if (elements.length > 0 && !confirm('This will replace your current board. Continue?')) {
                return;
            }

            clearCanvas();
            connections = data.connections || [];
            zoom = data.zoom || 1;
            panX = data.panX || 0;
            panY = data.panY || 0;

            updateCanvasTransform();
            document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;

            // Recreate elements
            data.elements.forEach(el => {
                createElement(el.type, el.x, el.y, el);
                elementIdCounter = Math.max(elementIdCounter, parseInt(el.id.split('-')[1]) || 0);
            });

            // Recreate connections
            setTimeout(() => renderConnections(), 100);

            alert('Board imported successfully!');
        } catch (err) {
            alert('Error importing file: ' + err.message);
        }
    };
    reader.readAsText(file);

    // Reset input so same file can be imported again
    event.target.value = '';
}

// ============================================================================
// COLLABORATION
// ============================================================================

let isCollaborative = false;
let roomCode = null;
let serverVersion = 0;
let pollInterval = null;
let votingActive = false;
let votesPerUser = 3;
let userVotes = [];
let myColor = '#4a9f6e';
let isOwner = false;
let lastCursorUpdate = 0;

// Check if we're in a room (URL has room code)
function initCollaboration() {
    const pathParts = window.location.pathname.split('/');
    const roomIdx = pathParts.indexOf('whiteboard');
    if (roomIdx >= 0 && pathParts[roomIdx + 1] && pathParts[roomIdx + 1].length >= 4) {
        roomCode = pathParts[roomIdx + 1].toUpperCase();
        loadBoardFromServer();
    }
}

async function loadBoardFromServer() {
    try {
        const response = await fetch(`/api/whiteboard/boards/${roomCode}/`);
        if (!response.ok) {
            if (response.status === 404) {
                alert('Board not found. It may have been deleted.');
                window.location.href = '/app/whiteboard/';
                return;
            }
            throw new Error('Failed to load board');
        }

        const data = await response.json();
        isCollaborative = true;
        serverVersion = data.version;
        votingActive = data.voting_active;
        votesPerUser = data.votes_per_user;
        userVotes = data.user_votes || [];
        myColor = data.my_color;
        isOwner = data.is_owner;

        // Set project from loaded board
        if (data.project_id) {
            currentProjectId = data.project_id;
            document.getElementById('project-select').value = currentProjectId;
            updateProjectLink(currentProjectId);
        }

        // Update UI
        document.getElementById('collab-controls').style.display = 'flex';
        document.getElementById('room-code-text').textContent = roomCode;
        if (isOwner) {
            document.getElementById('vote-toggle').style.display = 'block';
        }

        // Clear and load board
        clearCanvas(true);
        connections = data.connections || [];
        zoom = data.zoom || 1;
        panX = data.pan_x || 0;
        panY = data.pan_y || 0;

        updateCanvasTransform();
        document.getElementById('zoom-display').textContent = `${Math.round(zoom * 100)}%`;

        // Recreate elements
        (data.elements || []).forEach(el => {
            const domEl = createElement(el.type, el.x, el.y, el);
            elementIdCounter = Math.max(elementIdCounter, parseInt(el.id.split('-')[1]) || 0);

            // Add vote count if exists
            const voteCount = (data.vote_counts && data.vote_counts[el.id]) || 0;
            if (domEl) updateVoteDisplay(domEl, voteCount);
        });

        // Recreate connections
        setTimeout(() => renderConnections(), 100);

        // Update participants
        updateParticipantsList(data.participants);

        // Update voting UI
        updateVotingUI();

        // Start polling
        startPolling();

        showSyncStatus('synced', 'Connected');

    } catch (err) {
        console.error('Error loading board:', err);
        showSyncStatus('error', 'Failed to connect');
    }
}

function startPolling() {
    if (pollInterval) clearInterval(pollInterval);
    pollInterval = setInterval(pollForUpdates, 2000);
}

async function pollForUpdates() {
    if (!isCollaborative || !roomCode) return;

    try {
        const response = await fetch(`/api/whiteboard/boards/${roomCode}/`);
        if (!response.ok) return;

        const data = await response.json();

        // Check if we need to update
        if (data.version > serverVersion) {
            serverVersion = data.version;
            mergeServerState(data);
        }

        // Always update participants and votes
        updateParticipantsList(data.participants);
        if (data.vote_counts) updateAllVoteCounts(data.vote_counts);
        userVotes = data.user_votes || [];
        votingActive = data.voting_active;
        updateVotingUI();

        showSyncStatus('synced', 'Synced');
    } catch (err) {
        showSyncStatus('error', 'Connection lost');
    }
}

function mergeServerState(data) {
    clearCanvas(false);
    connections = data.connections || [];

    (data.elements || []).forEach(el => {
        const domEl = createElement(el.type, el.x, el.y, el);
        elementIdCounter = Math.max(elementIdCounter, parseInt(el.id.split('-')[1]) || 0);
    });

    setTimeout(() => renderConnections(), 50);
}

async function saveBoardToServer() {
    if (!isCollaborative || !roomCode) return;

    showSyncStatus('syncing', 'Saving...');

    try {
        const payload = {
            version: serverVersion,
            elements: elements,
            connections: connections,
            zoom: zoom,
            pan_x: panX,
            pan_y: panY,
        };
        if (currentProjectId) {
            payload.project_id = currentProjectId;
        }
        const response = await fetch(`/api/whiteboard/boards/${roomCode}/update/`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });

        if (response.status === 409) {
            const data = await response.json();
            serverVersion = data.server_version;
            mergeServerState(data);
            showSyncStatus('synced', 'Merged');
        } else if (response.ok) {
            const data = await response.json();
            serverVersion = data.version;
            showSyncStatus('synced', 'Saved');
        }
    } catch (err) {
        showSyncStatus('error', 'Save failed');
    }
}

// Debounced save
let saveTimeout = null;
function debouncedSave() {
    if (!isCollaborative) return;
    if (saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveBoardToServer, 500);
}

// Override saveState to also sync
const originalSaveState = saveState;
saveState = function() {
    originalSaveState();
    debouncedSave();
};

async function shareBoard() {
    if (isCollaborative) {
        copyRoomLink();
        return;
    }

    const name = prompt('Board name:', 'Untitled Board');
    if (!name) return;

    try {
        const payload = { name };
        if (currentProjectId) {
            payload.project_id = currentProjectId;
        }
        const response = await fetch('/api/whiteboard/boards/create/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });

        if (!response.ok) throw new Error('Failed to create board');

        const data = await response.json();
        roomCode = data.room_code;
        isCollaborative = true;
        isOwner = true;
        serverVersion = 0;

        await saveBoardToServer();

        window.history.pushState({}, '', `/app/whiteboard/${roomCode}/`);
        document.getElementById('collab-controls').style.display = 'flex';
        document.getElementById('room-code-text').textContent = roomCode;
        document.getElementById('vote-toggle').style.display = 'block';

        startPolling();
        copyRoomLink();
        alert(`Board created! Link copied to clipboard.\n${window.location.href}`);

    } catch (err) {
        console.error('Error creating board:', err);
        alert('Failed to create shared board.');
    }
}

function copyRoomLink() {
    const url = window.location.href;
    navigator.clipboard.writeText(url).then(() => {
        const display = document.getElementById('room-code-text');
        const original = display.textContent;
        display.textContent = 'Copied!';
        setTimeout(() => { display.textContent = original; }, 1500);
    });
}

function updateParticipantsList(participants) {
    const list = document.getElementById('participants-list');
    if (!participants || participants.length === 0) {
        list.innerHTML = '';
        return;
    }

    list.innerHTML = participants.map(p => `
        <div class="wb-participant" style="background:${p.color}" title="${p.username}${p.is_owner ? ' (owner)' : ''}">
            ${p.username.charAt(0).toUpperCase()}
        </div>
    `).join('');
}

function showSyncStatus(status, text) {
    let el = document.querySelector('.wb-sync-status');
    if (!el) {
        el = document.createElement('div');
        el.className = 'wb-sync-status';
        el.innerHTML = '<span class="wb-sync-dot"></span><span class="wb-sync-text"></span>';
        document.body.appendChild(el);
    }

    el.className = 'wb-sync-status ' + status;
    el.querySelector('.wb-sync-text').textContent = text;

    if (status === 'synced') {
        setTimeout(() => { el.style.opacity = '0.5'; }, 2000);
    } else {
        el.style.opacity = '1';
    }
}

// ============================================================================
// VOTING
// ============================================================================

async function toggleVoting() {
    if (!isCollaborative || !isOwner) return;

    const newState = !votingActive;
    const clearVotes = newState && confirm('Start new voting round? This will clear existing votes.');

    try {
        const response = await fetch(`/api/whiteboard/boards/${roomCode}/voting/`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                active: newState,
                clear_votes: clearVotes,
            }),
        });

        if (response.ok) {
            const data = await response.json();
            votingActive = data.voting_active;
            votesPerUser = data.votes_per_user;
            updateVotingUI();
        }
    } catch (err) {
        console.error('Error toggling voting:', err);
    }
}

function updateVotingUI() {
    const btn = document.getElementById('vote-toggle');
    const remaining = document.getElementById('votes-remaining');

    if (votingActive) {
        btn.classList.add('active');
        remaining.style.display = 'block';
        remaining.textContent = `${votesPerUser - userVotes.length} votes left`;

        document.querySelectorAll('.wb-element').forEach(el => {
            el.classList.add('voting-mode');
            el.classList.toggle('voted', userVotes.includes(el.id));
        });
    } else {
        btn.classList.remove('active');
        remaining.style.display = 'none';
        document.querySelectorAll('.wb-element').forEach(el => {
            el.classList.remove('voting-mode', 'voted');
        });
    }
}

function updateVoteDisplay(element, count) {
    if (!element) return;
    let badge = element.querySelector('.wb-vote-count');
    if (!badge) {
        badge = document.createElement('div');
        badge.className = 'wb-vote-count';
        element.appendChild(badge);
    }
    badge.textContent = count;
    badge.classList.toggle('zero', count === 0);
}

function updateAllVoteCounts(voteCounts) {
    document.querySelectorAll('.wb-element').forEach(el => {
        const count = voteCounts[el.id] || 0;
        updateVoteDisplay(el, count);
    });
}

async function voteOnElement(elementId) {
    if (!votingActive || !isCollaborative) return;

    if (userVotes.includes(elementId)) {
        // Remove vote
        try {
            const response = await fetch(`/api/whiteboard/boards/${roomCode}/vote/${elementId}/`, {
                method: 'DELETE',
            });
            if (response.ok) {
                const data = await response.json();
                userVotes = userVotes.filter(id => id !== elementId);
                updateVoteDisplay(document.getElementById(elementId), data.vote_count);
                updateVotingUI();
            }
        } catch (err) {
            console.error('Error removing vote:', err);
        }
    } else {
        // Add vote
        if (userVotes.length >= votesPerUser) {
            alert('No votes remaining. Remove a vote first.');
            return;
        }
        try {
            const response = await fetch(`/api/whiteboard/boards/${roomCode}/vote/`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ element_id: elementId }),
            });
            if (response.ok) {
                const data = await response.json();
                userVotes.push(elementId);
                updateVoteDisplay(document.getElementById(elementId), data.vote_count);
                updateVotingUI();
            } else {
                const err = await response.json();
                alert(err.error || 'Failed to vote');
            }
        } catch (err) {
            console.error('Error voting:', err);
        }
    }
}

// Voting click handler
canvasContainer.addEventListener('click', (e) => {
    if (!votingActive) return;
    const element = e.target.closest('.wb-element');
    if (element) {
        e.preventDefault();
        e.stopPropagation();
        voteOnElement(element.id);
    }
}, true);

// ============================================================================
// Project Selector
// ============================================================================

async function setupProjectSelector() {
    const select = document.getElementById('project-select');
    const link = document.getElementById('project-link');

    try {
        const response = await fetch('/api/core/projects/', { credentials: 'include' });
        if (!response.ok) return;
        const projects = await response.json();

        // Populate dropdown
        projects.forEach(p => {
            const opt = document.createElement('option');
            opt.value = p.id;
            opt.textContent = p.title;
            select.appendChild(opt);
        });

        // Check for project param in URL
        const urlParams = new URLSearchParams(window.location.search);
        const projectId = urlParams.get('project');
        if (projectId) {
            select.value = projectId;
            currentProjectId = projectId;
            updateProjectLink(projectId);
        }
    } catch (err) {
        console.error('Failed to load projects:', err);
    }

    // Handle selection change
    select.addEventListener('change', (e) => {
        currentProjectId = e.target.value || null;
        updateProjectLink(currentProjectId);
        // Update URL without reload
        const url = new URL(window.location);
        if (currentProjectId) {
            url.searchParams.set('project', currentProjectId);
        } else {
            url.searchParams.delete('project');
        }
        window.history.replaceState({}, '', url);
        // Save to server if collaborative
        if (isCollaborative && roomCode) {
            saveBoardToServer();
        }
    });
}

function updateProjectLink(projectId) {
    const link = document.getElementById('project-link');
    if (projectId) {
        link.href = '/app/projects/';
        link.style.display = 'flex';
    } else {
        link.style.display = 'none';
    }
}

// ============================================================================
// Initialize
// ============================================================================

setupProjectSelector();
loadBoardsList();
saveState(); // Save initial empty state
initCollaboration(); // Check for room code in URL
</script>
<script>
window.addEventListener('svendUserReady', function(e) {
    if (!e.detail.features || !e.detail.features.full_tools) showUpgradeModal();
});
</script>
{% endblock %}
